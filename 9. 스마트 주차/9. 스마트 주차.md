# 스마트 주차 
## 스마트 주차 보조 시스템 구현
본 프로젝트는 초음파 거리 센서(SR04), 4-Digit FND(HT16K33), 조도 센서, 푸시 스위치를 결합하여 “자동차의 후진 상황에서 주변 장애물과의 거리를 직관적으로 표시하는 HUD(Head-Up Display)” 형태의 스마트 주차 보조 시스템을 구현하는 것을 목표로 합니다.

단순히 거리만 표시하는 수준을 넘어, 조도에 따른 자동 디밍(밝기 조절), 기어 상태에 따른 표시 전환, 그리고 시각적 애니메이션 효과를 결합하여 실제 차량의 HUD 동작을 모사한 교육용 실습 예제입니다.

## 구성 요소별 역할
### 초음파 센서
물체까지의 거리를 음파의 왕복 시간을 통해 측정합니다.
- 측정 거리 범위: 약 2 cm ~ 400 cm
- 후진(R) 상태일 때 거리값을 실시간으로 측정하여 FND에 m 단위 소수점 2자리(예: 0.45 m) 로 표시합니다.

### FND 
거리값 및 시스템 상태를 표시하는 시각적 인터페이스 역할을 합니다.
- R 상태: 초음파 센서로 측정된 거리값을 왼쪽 1칸 공백 + m 단위 소수 2자리로 표시합니다.
- N 상태: ---- 표기 (중립 상태)
- D 상태: 네 자리 전체를 하나의 사각형으로 보고, 외곽 LED가 한 부분씩 꺼졌다 켜지는 애니메이션을 통해 “주행 준비 상태”를 표현합니다.

### 조도 센서
주변 밝기에 따라 FND의 밝기를 자동으로 조정합니다.
- 밝을수록 더 밝게, 어두울수록 더 어둡게 (정비례 디밍)
- 10단계 세분화로 자연스러운 변화를 구현하였으며, 내부적으로 EMA(지수 이동 평균) 필터를 적용해 조도 변화에 의한 깜빡임을 최소화했습니다.

### 푸시 스위치
자동차의 기어 상태를 모사합니다.
| 스위치 | 기능 | 설명 |
| :--- | :--- | :--- |
| D | Drive | 주행 대기 / 사각형 외곽 애니메이션 |
| N | Neutral | 중립 상태(`----`) 표시 |
| R | Reverse | 거리 측정 및 거리 표시 활성화 |

## 동작 구조
1. N(중립) 상태
    - 4-Digit FND에 ---- 출력
    - 센서 대기 상태 유지
2. D(주행) 상태
    - 4개의 FND를 하나의 사각형으로 보고 외곽 LED(A,B,C,D,E,F)가 모두 켜진 상태에서 둘레를 따라 한 부분씩 OFF 되는 순차 애니메이션이 반복 실행됩니다.
3. R(후진) 상태
    - 초음파 센서를 이용해 실시간 거리 측정
    - 유효 거리일 경우 m 단위 소수 2자리로 표시
    - 감지 실패 시 ---- 표시
    - 주변 조도에 따라 자동으로 밝기 보정

## 하드웨어 연결 
<details> 
<summary><b>초음파 센서 연결 정보 [Click]</b></summary>

| Pin | 연결 대상 | 설명 |
| :---: | :---: | :--- |
| 5V | +5V | 전원 |
| GND | GND | 접지 |
| 9 | TRIG | 초음파 트리거 출력 |
| 8 | ECHO | 초음파 수신 입력 |

</details> 
<details>
<summary><b>조도 센서 연결 정보 [Click]</b></summary>

| Pin | 연결 대상 | 설명 |
| :---: | :---: | :--- |
| 5V | +5V | 전원 |
| GND | GND | 접지 |
| A0 | A | 조도 아날로그 출력 |

</details> 
<details>
<summary><b>4-Digit FND 연결 정보 [Click]</b></summary>

| Pin | 연결 대상 | 설명 |
| :---: | :---: | :--- |
| 5V | +5V | 전원 |
| GND | GND | 접지 |
| SDA | 20 | I²C 데이터 |
| SCL | 21 | I²C 클록 |

</details> 
<details>
<summary><b>기어 스위치 연결 정보 [Click]</b></summary>

| Pin | 연결 대상  | 설명 |
| :---: | :---: | :--- |
| 4 | Drive | 스위치 입력 |
| 5 | Neutral | 스위치 입력 |
| 6 | Reverse | 스위치 입력 |

</details>

## 스마트 주차 코드 작성

```cpp
#include <Wire.h>
#include <math.h>

#define DEBUG_ULTRA 0
#define DP_IN_SEGMENT true
#define HT16K33_ADDR 0x70

const int PIN_TRIG = 8;
const int PIN_ECHO = 9;
const int PIN_LIGHT = A0;
const int PIN_D = 4;
const int PIN_N = 5;
const int PIN_R = 6;

const uint8_t SEG_A=1<<0, SEG_B=1<<1, SEG_C=1<<2, SEG_D=1<<3, SEG_E=1<<4, SEG_F=1<<5, SEG_G=1<<6;

uint8_t digitMap[10] = {
  0b00111111,
  0b00000110,
  0b01011011,
  0b01001111,
  0b01100110,
  0b01101101,
  0b01111101,
  0b00000111,
  0b01111111,
  0b01101111 
};
const uint8_t SEG_DASH  = 0b01000000;
const uint8_t SEG_BLANK = 0x00;
const uint8_t POS_ADDR[4] = {0x00, 0x02, 0x04, 0x06};

static inline void ht_cmd(uint8_t c){ Wire.beginTransmission(HT16K33_ADDR); Wire.write(c); Wire.endTransmission(); }
void ht_init(){
  Wire.begin();
  ht_cmd(0x21);
  ht_cmd(0x81);
  ht_cmd(0xE0 | 0x0F);
  Wire.beginTransmission(HT16K33_ADDR);
  Wire.write(0x00); for(int i=0;i<16;i++) Wire.write(0x00);
  Wire.endTransmission();
}

void ht_brightness(uint8_t lvl){ if(lvl>15) lvl=15; ht_cmd(0xE0 | lvl); }

void ht_write_digit(uint8_t idx, uint8_t seg, bool dp){
  if(idx>3) return;
  uint8_t even = POS_ADDR[idx];
  uint8_t odd  = even + 1;

  uint8_t seg_out = seg;
  uint8_t icon_out = 0x00;

  if (DP_IN_SEGMENT) {
    if (dp) seg_out |= 0x80;
  } else {
    if (dp) icon_out |= 0x01;
  }

  Wire.beginTransmission(HT16K33_ADDR);
  Wire.write(even);
  Wire.write(seg_out);
  Wire.write(icon_out);
  Wire.endTransmission();
}

void disp_dashes(){ for(int i=0;i<4;i++) ht_write_digit(i, SEG_DASH, false); }

void disp_m2_shifted(float m){
  if (m < 0.0f) { disp_dashes(); return; }
  if (m > 9.99f) m = 9.99f;
  int hundred = (int)(m*100.0f + 0.5f);
  int iPart = hundred/100;
  int d1 = (hundred/10)%10;
  int d2 = hundred%10;

  ht_write_digit(0, SEG_BLANK, false);
  ht_write_digit(1, digitMap[iPart], true);
  ht_write_digit(2, digitMap[d1], false);
  ht_write_digit(3, digitMap[d2], false);
}

static inline void ultra_trigger(){
  digitalWrite(PIN_TRIG, LOW);  delayMicroseconds(3);
  digitalWrite(PIN_TRIG, HIGH); delayMicroseconds(10);
  digitalWrite(PIN_TRIG, LOW);
}
unsigned long read_echo_us(){
  ultra_trigger();
  return pulseIn(PIN_ECHO, HIGH, 50000UL);
}

float read_distance_m(){
  static unsigned long lastTrig = 0;
  unsigned long now = millis();
  if (now - lastTrig < 60) delay(60 - (now - lastTrig));
  lastTrig = millis();

  unsigned long t[3];
  for(int i=0;i<3;i++){ t[i]=read_echo_us(); delay(5); }
  if(t[0]>t[1]){ auto x=t[0]; t[0]=t[1]; t[1]=x; }
  if(t[1]>t[2]){ auto x=t[1]; t[1]=t[2]; t[2]=x; }
  if(t[0]>t[1]){ auto x=t[0]; t[0]=t[1]; t[1]=x; }

  unsigned long us = t[1];
  if(us==0) return -1.0f;

  float cm = (us * 0.0343f) * 0.5f;
  return cm / 100.0f;
}

const uint8_t BR_MAP[10] = {1,2,3,4,5,7,9,11,13,15};
float light_ema = 0.0f;
const float LIGHT_ALPHA = 0.20f;

uint8_t light_to_brightness_10step(uint16_t adc){
  light_ema = (1.0f - LIGHT_ALPHA)*light_ema + LIGHT_ALPHA*(float)adc;
  int idx = (int)(light_ema / 102.4f);
  if (idx < 0) idx = 0;
  if (idx > 9) idx = 9;
  return BR_MAP[idx];
}

enum Gear { GEAR_D, GEAR_N, GEAR_R };
Gear currentGear = GEAR_N;

bool pressed_stable(int pin){
  if (digitalRead(pin)==HIGH){ delay(20); return (digitalRead(pin)==HIGH); }
  return false;
}

void update_gear_latch(){
  bool rNow = pressed_stable(PIN_R);
  bool dNow = pressed_stable(PIN_D);
  bool nNow = pressed_stable(PIN_N);
  if(rNow){ currentGear=GEAR_R; return; }
  if(dNow){ currentGear=GEAR_D; return; }
  if(nNow){ currentGear=GEAR_N; return; }  
}

static inline uint8_t segs(bool A,bool B,bool C,bool D,bool E,bool F,bool G=false){
  uint8_t m=0;
  if(A) m|=SEG_A; if(B) m|=SEG_B; if(C) m|=SEG_C; if(D) m|=SEG_D;
  if(E) m|=SEG_E; if(F) m|=SEG_F; if(G) m|=SEG_G;
  return m;
}

const uint8_t BASE_DIGIT[4] = {
  segs(1,0,0,1,1,1),
  segs(1,0,0,1,0,0),
  segs(1,0,0,1,0,0),
  segs(1,1,1,1,0,0) 
};

const uint8_t OFF_DIGIT[12] = { 0,1,2,3,  3,3,  3,2,1,0,  0,0 };
const uint8_t OFF_SEGID[12] = { 'A','A','A','A','B','C','D','D','D','D','F','E' };

static inline uint8_t segMaskFromId(uint8_t id){
  switch(id){
    case 'A': return SEG_A;
    case 'B': return SEG_B;
    case 'C': return SEG_C;
    case 'D': return SEG_D;
    case 'E': return SEG_E;
    case 'F': return SEG_F;
    default:  return 0;
  }
}

void driveAnimationBigRect(){
  static uint8_t phase = 0;
  uint8_t buf[4] = { BASE_DIGIT[0], BASE_DIGIT[1], BASE_DIGIT[2], BASE_DIGIT[3] };
  uint8_t d = OFF_DIGIT[phase];
  uint8_t m = segMaskFromId(OFF_SEGID[phase]);
  buf[d] &= ~m;

  for(uint8_t i=0;i<4;i++) ht_write_digit(i, buf[i], false);
  phase = (phase + 1) % 12;
}

float lastValidM = -1.0f;

void setup(){
#if DEBUG_ULTRA
  Serial.begin(115200); 
  Serial.println(F("Smart Parking Assist (D animation, N dashes, R distance m.xx)"));
#endif
  pinMode(PIN_TRIG, OUTPUT);
  digitalWrite(PIN_TRIG, LOW);
  pinMode(PIN_ECHO, INPUT);
  pinMode(PIN_LIGHT, INPUT);
  pinMode(PIN_D, INPUT);
  pinMode(PIN_N, INPUT);
  pinMode(PIN_R, INPUT);

  Wire.begin();
  ht_init();
  light_ema = analogRead(PIN_LIGHT);
  disp_dashes();
}

void loop(){
  uint16_t adc = analogRead(PIN_LIGHT);
  ht_brightness(light_to_brightness_10step(adc));

  update_gear_latch();

  if (currentGear == GEAR_R) {
    float m = read_distance_m();
    if (m > 0.0f) lastValidM = m;
    if (lastValidM > 0.0f) disp_m2_shifted(lastValidM);
    else disp_dashes();
    delay(3);
  } else if (currentGear == GEAR_D) {
    driveAnimationBigRect();
    delay(120);
  } else {
    disp_dashes();
    delay(60);
  }
}
```