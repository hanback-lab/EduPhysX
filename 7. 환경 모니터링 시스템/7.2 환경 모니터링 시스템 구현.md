# 환경 모니터링 시스템 구현 
우리 생활과 산업 현장에서 안전과 효율성을 높이기 위한 환경 모니터링의 필요성을 실제 시스템으로 구현해보는 데 목적이 있습니다.
환경 요소 중에서도 온도, 습도, 가스, 조도는 인간의 쾌적한 생활뿐 아니라 설비의 안정성과 직결되는 핵심 지표입니다. 예를 들어, 온도와 습도가 적절하지 않으면 전자기기나 저장 식품의 품질이 저하되고, 가스 농도는 누출 시 화재·폭발과 같은 큰 위험을 초래할 수 있습니다. 또한 조도의 변화는 작업자의 집중도와 에너지 소비 관리에 큰 영향을 줍니다.

여기서는 네 가지 센서를 결합해 실시간으로 환경 데이터를 측정하고, 직관적인 방식으로 표시·경보하는 시스템을 구축하였습니다. 단순히 센서를 읽는 수준을 넘어서, 각 센서의 특성과 데이터를 활용한 임계치 판정을 통해 위험 상황을 감지하고 사용자에게 즉시 알림을 주는 기능을 포함시켰습니다.

궁극적으로 이 프로젝트는 센서 제어와 데이터 처리, 사용자 인터페이스를 모두 아우르는 통합형 환경 모니터링 시스템의 기초 모델을 제시하는 것이며, 이를 통해 학생들은 개별 센서 제어를 넘어선 시스템적 설계 능력을 학습할 수 있습니다. 또한 로컬 수준의 경보 체계에서 더 나아가 IoT·스마트홈·스마트팩토리 분야로 확장 가능한 기반을 마련하는 데 의미가 있습니다.

## 구성 요소별 역할
### 온도 센서
환경의 기본적인 안정성을 확인하는 핵심 지표로 사용됩니다.
전자기기 동작, 식품 보관, 작업 공간의 쾌적성 등 다양한 분야에서 온도 관리가 필수적이므로, 정밀하게 측정할 수 있는 센서를 선택했습니다.
이 센서를 통해 시스템은 환경의 과열이나 비정상 상태를 조기에 감지할 수 있습니다.

### 습도 센서
공기 중 수분의 비율을 측정하여 환경의 쾌적성과 안정성을 평가합니다.
습도는 곰팡이 발생, 전자 부품의 부식, 공정 품질 저하 등과 직접 연결되기 때문에 중요한 감시 대상입니다.
단순히 수치를 표시하는 것을 넘어, 일정 수준 이상일 경우 경보를 통해 관리자가 즉시 대응할 수 있도록 설계되었습니다.

### 가스 센서
가연성 또는 유해 가스를 감지하여 안전 관리의 핵심 역할을 합니다.
누출이나 농도 증가를 빠르게 감지하여 화재나 폭발 같은 위험 상황을 예방하는 것이 목적입니다.
이 센서는 경보 시스템과 직결되어, 안전 관리 기능을 실질적으로 체험할 수 있도록 해줍니다.

### 조도 센서
빛의 세기를 측정하여 작업 환경의 밝기를 모니터링합니다.
조도는 작업자의 시각적 편의성뿐 아니라, 불필요한 조명 사용을 줄여 에너지 효율을 높이는 관리 지표로도 활용됩니다.
이를 통해 단순한 측정 기능을 넘어, 환경 효율 관리라는 교육적 확장성까지 고려할 수 있습니다.

### TextLCD
시스템이 수집한 환경 데이터를 사용자에게 직관적으로 전달하는 인터페이스 역할을 합니다.
단순히 숫자를 보여주는 것을 넘어, 센서별 이름과 측정값, 알람 상태까지 동시에 표시할 수 있어 환경 상태를 한눈에 파악할 수 있습니다.
작은 크기와 저전력 특성을 가지고 있어, 학습용·시범용 시스템에서도 부담 없이 사용할 수 있습니다.
버튼과 함께 활용하면, 제한된 표시 공간 속에서도 여러 센서 정보를 선택적으로 확인할 수 있다는 장점이 있습니다.

### LED
환경 상태를 즉시 시각적으로 표현하는 경보 장치로 사용됩니다.
센서별 알람, 전체 위험 여부, 시스템 모드 상태 등을 다양한 패턴(켜짐/꺼짐/점멸)으로 표현할 수 있습니다.
단순하고 직관적이어서, 사용자가 멀리서도 위험 여부를 빠르게 인지할 수 있게 해줍니다.
센서 데이터와 LCD 표시가 세부 정보를 제공한다면, LED는 즉각적 경보와 직관적 피드백을 담당합니다.

## 프로젝트 개요 
이 프로젝트는 다양한 환경 센서(온도, 습도, 가스, 조도) 를 하나의 마이크로컨트롤러에서 통합적으로 제어하고, 측정된 데이터를 Text LCD(20×4) 와 LED 인디케이터로 시각화하며, 버튼 입력(인터럽트 기반) 을 통해 자동/수동 모드 전환 및 표시 화면 변경을 수행하는 실습 예제입니다.

이 예제는 센서 계측 + 데이터 시각화 + 사용자 인터페이스(UI) 제어의 개념을 한 번에 학습할 수 있습니다. 즉, 단순한 센서 읽기 수준을 넘어, 시스템 통합형 IoT 기초 프로젝트의 구조를 익히는 데 목적이 있습니다.

## 동작 구조 
시스템은 크게 `측정(Measurement)` – `판정(Decision)` – `표시(Display)` 세 단계로 동작합니다.

1. 센서 데이터 수집
    - 온도 센서: I²C 통신을 통해 온도를 읽음 (12bit 데이터 → 섭씨 변환)
    - 습도, 가스, 조도 센서: ADC 입력으로 0~1023 값을 읽어 전압 → 물리량으로 변환
    - 각 센서의 측정 주기는 약 120ms, 자동 모드에서는 4초 주기로 화면 전환

2. 임계값 판정 (Hysteresis 적용)
    - 각 센서는 상·하한 임계값(ON/OFF)을 가지고 있으며, 일정 범위 내에서 토글되지 않도록 히스테리시스(hysteresis) 처리
    - 임계값 초과 시 해당 알람 플래그(aTemp, aHumi, aGas, aLux)가 활성화

### 동작 모드 및 버튼 제어 
버튼(D2)은 인터럽트(Interrupt) 방식으로 처리되어, LCD 갱신 중에도 누락 없이 입력을 감지할 수 있습니다.
| 버튼 조작 | 기능 | 설명 |
| :--- | :--- | :--- |
| 짧게 누름 (0.03~1.5초) | 화면 전환(View Change) | 수동 모드일 때만 온습도 ↔ 가스조도 화면 전환 |
| 길게 누름 (1.5초 이상) | 모드 전환(Mode Change) | 자동 모드(AUTO) ↔ 수동 모드(MANUAL) 전환 |

### LED 인디케이터 
8개의 LED는 두 개의 센서 쌍을 표현합니다. 각 4개의 LED는 해당 센서의 상태 레벨(0~3단계) 을 시각화하며, 임계 초과 시 마지막 LED가 점멸(blink) 형태로 알람을 표시합니다.
| LED 그룹 | 대응 센서 | 표시 의미 |
| :--- | :--- | :--- |
| L0~L3 | 온도/가스 | 값이 커질수록 LED 점등 수 증가 |
| L4~L7 | 습도/조도 | 값이 커질수록(또는 조도는 낮을수록) LED 점등 수 증가 |
| 마지막 칸(3번,7번) | - | 알람 발생 시 점멸 (blink) 표시 |

## 하드웨어 연결 
<details>
<summary><b>TextLCD 연결 정보 [Click]</b></summary>

| Pin | 연결 대상 | 설명 |
|:---:|:---:|:---|
| 5V | +5V | 전원 |
| GND | GND | 접지 |
| 20 | SDA | I2C Data |
| 21 | SCL | I2C Clock |

</details>

<details>
<summary><b>LED 연결 정보 [Click]</b></summary>

| Pin | 연결 대상 | 설명 |
|:---:|:---:|:---|
| GND | GND | 접지 |
| 4 | D0 | LED 0 |
| 5 | D1 | LED 1 |
| 6 | D2 | LED 2 |
| 7 | D3 | LED 3 |
| 8 | D4 | LED 4 |
| 9 | D5 | LED 5 |
| 10 | D6 | LED 6 |
| 11 | D7 | LED 7 |

</details>

<details>
<summary><b>PushSwitch 연결 정보 [Click]</b></summary>

| Pin | 연결 대상 | 설명 |
|:---:|:---:|:---|
| 5V | +5V | 전원 |
| GND | GND | 접지 |
| 2 | SW0 | Push Switch 0 |

</details>

<details>
<summary><b>온도 센서 연결 정보[Click]</b></summary>

| Pin | 연결 대상 | 설명 |
|:---:|:---:|:---|
| 5V | +5V | 전원 |
| GND | GND | 접지 |
| 20 | SDA | I2C Data |
| 21 | SCL | I2C Clock |

</details>

<details>
<summary><b>습도 센서 연결 정보 [Click]</b></summary>

| Pin | 연결 대상 | 설명 |
|:---:|:---:|:---|
| 5V | +5V | 전원 |
| GND | GND | 접지 |
| A0 | A | Humidity Sensor |

</details>

<details>
<summary><b>가스 센서 연결 정보 [Click]</b></summary>

| Pin | 연결 대상 | 설명 |
|:---:|:---:|:---|
| 5V | +5V | 전원 |
| GND | GND | 접지 |
| A1 | A | GAS Sensor |

</details>

<details>
<summary><b>조도 센서 연결 정보 [Click]</b></summary>

| Pin | 연결 대상 | 설명 |
|:---:|:---:|:---|
| 5V | +5V | 전원 |
| GND | GND | 접지 |
| A2 | A | Light Sensor |

</details>

## 프로그램 작성 
```arduino
#include <Wire.h>
#include <LiquidCrystal_I2C.h>
#include <stdarg.h>

#define TMP102_ADDR 0x48
#define LCD_ADDR 0x27
#define LCD_COLS 20
#define LCD_ROWS 4

const int PIN_BTN = 2;
const int LEDS[8] = {4,5,6,7,8,9,10,11};
const int PIN_A_HUMI = A0;
const int PIN_A_GAS = A1;
const int PIN_A_LUX = A2;

LiquidCrystal_I2C lcd(LCD_ADDR, LCD_COLS, LCD_ROWS);

enum View { VIEW_TH=0, VIEW_GL=1, VIEW_COUNT };
enum Mode { MODE_AUTO=0, MODE_MANUAL=1 };
Mode mode = MODE_AUTO;
View view = VIEW_TH;

unsigned long lastCycleMs = 0;
const unsigned long cyclePeriodMs = 4000;
unsigned long blinkMs = 0;
bool blinkOn = false;

const float TEMP_ON = 30.0f, TEMP_OFF = 29.0f;
const float HUMI_ON = 80.0f, HUMI_OFF = 75.0f;
const int GAS_ON = 500, GAS_OFF = 450;
const int LUX_ON = 20, LUX_OFF = 25;

bool aTemp=false, aHumi=false, aGas=false, aLux=false;

volatile bool btnIsDown = false;
volatile uint32_t btnLastChangeUs = 0;
volatile uint32_t btnPressStartUs = 0;
volatile uint8_t  btnEvent = 0;

const uint32_t DEBOUNCE_US = 20000;
const uint32_t LONGPRESS_MS = 1500;
const uint32_t SHORT_MIN_MS = 30;

static inline void lcdPrintLine(uint8_t row, const char* s) {
  lcd.setCursor(0, row);
  char buf[21];
  uint8_t i=0;
  while (s[i] && i<20) { buf[i] = s[i]; i++; }
  while (i<20) { buf[i++] = ' '; }
  buf[20] = '\0';
  lcd.print(buf);
}

#ifndef IRAM_ATTR
#define IRAM_ATTR
#endif

void IRAM_ATTR onBtnChange() {
  uint32_t now = micros();
  if (now - btnLastChangeUs < DEBOUNCE_US) 
    return;
  btnLastChangeUs = now;

  int level = digitalRead(PIN_BTN);
  if (level == LOW && !btnIsDown) {
    btnIsDown = true;
    btnPressStartUs = now;
  } else if (level == HIGH && btnIsDown) {
    btnIsDown = false;
    uint32_t dur_ms = (now - btnPressStartUs) / 1000UL;
    if (dur_ms >= LONGPRESS_MS)      
      btnEvent = 2;
    else if (dur_ms > SHORT_MIN_MS)  
      btnEvent = 1;
  }
}

void processButtonEvents() {
  uint8_t ev;
  noInterrupts(); 
  ev = btnEvent; btnEvent = 0; 
  interrupts();
  if (ev == 0) 
    return;

  if (ev == 2) {
    mode = (mode==MODE_AUTO)? MODE_MANUAL : MODE_AUTO;
  } else if (ev == 1) {
    if (mode == MODE_MANUAL) 
      view = (View)((view + 1) % VIEW_COUNT);
  }
}

float readTMP102C() {
  Wire.beginTransmission(TMP102_ADDR);
  Wire.write(0x00);
  Wire.endTransmission(false);
  Wire.requestFrom(TMP102_ADDR, 2);
  if (Wire.available() < 2) 
    return NAN;
  uint8_t msb = Wire.read();
  uint8_t lsb = Wire.read();
  int16_t raw = ((msb << 8) | lsb) >> 4;
  if (raw & 0x800) 
    raw |= 0xF000;
  return raw * 0.0625f;
}

float readHIH4030() {
  int raw = analogRead(PIN_A_HUMI);
  float v = raw * (5.0f/1023.0f);
  float ratio = v / 5.0f;
  float rh = (ratio - 0.16f) / 0.0062f;
  if (rh < 0) rh = 0; if (rh > 100) rh = 100;
  return rh;
}

int readMQ5() { 
  return analogRead(PIN_A_GAS); 
}

int readTEMT6000() { 
  return analogRead(PIN_A_LUX); 
}

void evalAlarms(float tC, float rh, int gas, int lux) {
  if (!aTemp && tC > TEMP_ON) 
    aTemp = true;
  else if (aTemp && tC < TEMP_OFF) 
    aTemp = false;

  if (!aHumi && rh > HUMI_ON) 
    aHumi = true;
  else if (aHumi && rh < HUMI_OFF) 
    aHumi = false;

  if (!aGas && gas > GAS_ON) 
    aGas = true;
  else if (aGas && gas < GAS_OFF) 
    aGas = false;

  if (!aLux && lux < LUX_ON) 
    aLux = true;
  else if (aLux && lux > LUX_OFF) 
    aLux = false;
}

uint8_t levelFromBand(float val, float off, float on, bool invert) {
  if (!invert) {
    if (val <= off) return 0;
    if (val >= on)  return 4;
    float p = (val - off) / (on - off);
    uint8_t lvl = (uint8_t)(p * 4.0f + 0.001f);
    return (lvl>3)?3:lvl;
  } else {
    if (val >= off) return 0;
    if (val <= on)  return 4;
    float p = (off - val) / (off - on);
    uint8_t lvl = (uint8_t)(p * 4.0f + 0.001f);
    return (lvl>3)?3:lvl;
  }
}

void drawBarGroup(uint8_t groupStartIndex, uint8_t level, bool alarm, bool blinkOn) {
  for (int i=0;i<4;i++) {
    bool on = (i < level);
    if (alarm) {
      if (i < 3) on = true;
      else on = blinkOn;
    }
    digitalWrite(LEDS[groupStartIndex + i], on ? HIGH : LOW);
  }
}

void updateLEDs(uint8_t lvlLeft, bool alarmLeft, uint8_t lvlRight, bool alarmRight) {
  unsigned long now = millis();
  if (now - blinkMs >= 250) { 
    blinkMs = now; 
    blinkOn = !blinkOn; 
  }
  drawBarGroup(0, lvlLeft,  alarmLeft,  blinkOn);
  drawBarGroup(4, lvlRight, alarmRight, blinkOn);
}

void renderTH(float tC, float rh) {
  char line[32];
  lcd.setCursor(0, 0); lcd.print("TEMP :   "); lcd.print(tC,2); lcd.print("C");
  lcd.setCursor(0, 1); lcd.print("HUMI :   "); lcd.print(rh,2); lcd.print("%");
  snprintf(line, sizeof(line), "MODE : %s", (mode==MODE_AUTO?"AUTO":"MANUAL"));
  lcdPrintLine(2, line);
  snprintf(line, sizeof(line), "ALRM : T%c  H%c",(aTemp?'*':'-'), (aHumi?'*':'-'));
  lcdPrintLine(3, line);
}

void renderGL(int gas, int lux) {
  char line[32];
  snprintf(line, sizeof(line), "GAS  : %7d", gas);
  lcdPrintLine(0, line);
  snprintf(line, sizeof(line), "LUX  : %7d", lux);
  lcdPrintLine(1, line);
  snprintf(line, sizeof(line), "MODE : %s", (mode==MODE_AUTO?"AUTO":"MANUAL"));
  lcdPrintLine(2, line);
  snprintf(line, sizeof(line), "ALRM : G%c  L%c",(aGas?'*':'-'), (aLux?'*':'-'));
  lcdPrintLine(3, line);
}

void setup() {
  Wire.begin();
  Serial.begin(115200);

  for (int i=0;i<8;i++) { 
    pinMode(LEDS[i], OUTPUT); 
    digitalWrite(LEDS[i], LOW); 
  }

  pinMode(PIN_BTN, INPUT_PULLUP);
  attachInterrupt(digitalPinToInterrupt(PIN_BTN), onBtnChange, CHANGE);

  lcd.init();
  lcd.backlight();
  lcdPrintLine(0, "Env Monitor Init...");
  lcdPrintLine(1, "TMP/HUMI/GAS/LUX");
  lcdPrintLine(2, "Mode:AUTO  View:TH");
  lcdPrintLine(3, "Ready");
  delay(1000);
  lcd.clear();
}

void loop() {
  processButtonEvents();
  unsigned long now = millis();
  if (mode==MODE_AUTO && now - lastCycleMs >= cyclePeriodMs) {
    view = (View)((view + 1) % VIEW_COUNT);
    lastCycleMs = now;
  }

  float tC = readTMP102C();
  float rh = readHIH4030();
  int gas = readMQ5();
  int lux = readTEMT6000();
  evalAlarms(tC, rh, gas, lux);

  uint8_t lvlT = levelFromBand(tC, TEMP_OFF, TEMP_ON, false);
  uint8_t lvlH = levelFromBand(rh, HUMI_OFF, HUMI_ON, false);
  uint8_t lvlG = levelFromBand(gas, GAS_OFF, GAS_ON, false);
  uint8_t lvlL = levelFromBand(lux, LUX_OFF, LUX_ON, true);

  if (view == VIEW_TH) {
    updateLEDs(lvlT, aTemp, lvlH, aHumi);
    renderTH(tC, rh);
  } else {
    updateLEDs(lvlG, aGas, lvlL, aLux);
    renderGL(gas, lux);
  }
  delay(120);
}
```