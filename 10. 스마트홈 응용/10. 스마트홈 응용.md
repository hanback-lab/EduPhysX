# 스마트 홈 응용 
## 스마트 창문 제어 시스템 
본 프로젝트는 가스 누출 감지 및 사용자 인증(비밀번호 입력)을 통한 창문 자동 개폐 시스템을 구현하는 것을 목표로 합니다. 가스 센서, 습도 센서, Text LCD, Keypad, Servo 모터를 결합하여,
일정 농도 이상의 가스 감지 시 자동으로 창문을 열어 환기시키고, 사용자가 Keypad를 이용해 비밀번호를 입력하면 수동으로 창문을 열고 닫을 수 있는 스마트홈 응용 시스템 설계를 실습합니다.

## 구성 요소별 역할 
### 가스 센서
- 메탄, 부탄, 액화가스 등의 농도를 감지하는 아날로그 센서입니다.
- 전압 출력을 이용해 ppm 단위로 가스 농도를 계산합니다.
- 설정된 임계값(예: 300ppm)을 초과할 경우 자동 환기 모드가 활성화됩니다.
  - 창문이 부분적으로(45°) 열리고 10초간 유지 후 자동으로 닫힙니다.

### 습도 센서
- 공기 중 상대습도를 0~100% 범위로 측정합니다.
- LCD에 실시간으로 표시되어 환경 모니터링 기능을 제공합니다.
- 향후 확장 시, 습도 조건에 따른 자동 제어(예: 결로 방지)에도 활용 가능합니다.

### Keypad
- 비밀번호 입력 인터페이스 역할을 합니다.
- 기본 비밀번호는 “1234”, 확인키는 F로 설정되어 있습니다.
- 0 올바른 비밀번호 입력 시 서보 모터가 90° 회전하여 창문을 완전히 엽니다.
- LCD에 입력 중인 비밀번호와 시스템 상태가 표시됩니다.
- 입력 후 5초 동안 열림 상태를 유지하고 자동으로 닫힙니다.

### Servo 모터
- 창문을 개폐하는 구동 장치입니다.
- 닫힘(0°), 환기(45°), 열림(90°)의 세 가지 위치로 동작합니다.
- Keypad 입력과 가스 감지 두 경우 모두 동일 모터를 사용하지만, 동작 각도가 달라 상황별 동작을 시각적으로 구분할 수 있습니다.

| 동작 조건 | 각도 | 상태 | 유지 시간 |
| :---- | :---: | :--- | :---: |
| 키패드 비밀번호 입력 성공 | 90° | 완전 개방 | 5초 |
| 가스 농도 임계 초과 | 45° | 부분 개방(환기) | 10초 |
| 자동 닫힘 | 0° | 닫힘(READY) | 즉시 |

### TextLCD
- 각 센서 데이터와 시스템 상태를 실시간으로 표시합니다.

| 줄 번호 | 내용 |
| :---: | :--- |
| 0행 | 가스 농도 (ppm) |
| 1행 | 습도 (%) |
| 2행 | 비밀번호 입력 상태 (`PW: ****`) |
| 3행 | 현재 시스템 상태 (`READY`, `OPEN(90deg)`, `VENTILATING(45deg)` 등) |

## 동작 구조 
1. 정상 대기(READY)
    - LCD에 가스·습도 값 표시
    - Keypad 입력 대기
    - 가스 농도 < 300ppm
    - 서보 모터 각도: 0°
2. 수동 열림(Keypad 비밀번호 입력)
    - 올바른 비밀번호 입력 시 → “OPENING” 상태
    - 서보가 90°로 이동
    - LCD: STATUS: OPEN(90deg)
    - 5초 후 자동 닫힘 → READY로 복귀
3. 자동 환기(Gas 감지)
    - 가스 농도 ≥ 300ppm → “VENTILATING” 상태
    - 서보가 45°로 이동
    - LCD: STATUS: VENTILATING(45deg)
    - 10초 후 자동 닫힘 → READY로 복귀

## 하드웨어 연결 
<details> 
<summary><b>가스 센서 연결 정보 [Click]</b></summary>

|  Pin | 연결 대상 | 설명 |
| :---: | :---: | :--- |
| VCC | +5V | 전원 |
| GND | GND | 접지 |
| A | A0 | 가스 농도 아날로그 출력 |

</details> 
<details>
<summary><b>습도 센서 연결 정보 [Click]</b></summary>

| Pin | 연결 대상 | 설명 |
| :---: | :---: | :--- |
| VCC | +5V | 전원 |
| GND | GND | 접지 |
| A | A1 | 습도 아날로그 출력 |

</details> 
<details> 
<summary><b>Keypad 연결 정보 [Click]</b></summary>

|  Pin | 연결 대상 | 설명 |
| :---: | :---: | :--- |
| 7~4 | R0~R3 | 감지선 (INPUT_PULLUP) |
| 11~8 | C0~C3 | 스캔선 (OUTPUT) |

</details> 
<details> 
<summary><b>Servo 모터 연결 정보 [Click]</b></summary>

| Pin | 연결 대상 | 설명 |
|:---:|:---:|:---|
| 5V | Red Cable | 전원 |
| GND | Brown Cable | 접지 |
| 13 | Yellow Cable | Servo Motor PWM |

</details> 
<details> 
<summary><b>TextLCD 연결 정보 [Click]</b></summary>

| Pin | 연결 대상 | 설명 |
|:---:|:---:|:---|
| 5V | +5V | 전원 |
| GND | GND | 접지 |
| 20 | C | I2C Clock |
| 21 | D | I2C Data |

</details>

## 스마트 창문 제어 코드
```cpp
#include <Wire.h>
#include <LiquidCrystal_I2C.h>
#include <Keypad.h>
#include <Servo.h>

#define LCD_ADDR 0x27
#define LCD_COLS 20
#define LCD_ROWS 4
LiquidCrystal_I2C lcd(LCD_ADDR, LCD_COLS, LCD_ROWS);

const int PIN_GAS = A0;
const int PIN_HUM = A1;
float VCC=5.0, RL=10000.0, R0=9000.0;
float A_coef=574.25, B_coef=-2.222;
const float GAS_THRESH_PPM=300.0;

const int SERVO_PIN = 13;
const int SERVO_OPEN_ANGLE_KEYPAD = 90;
const int SERVO_OPEN_ANGLE_VENT = 45;
const int SERVO_CLOSE_ANGLE = 0;
Servo servoWindow;

const byte ROWS=4, COLS=4;
char keys[ROWS][COLS]={
  {'1','2','3','A'},
  {'4','5','6','B'},
  {'7','8','9','C'},
  {'E','0','F','D'}
};
byte rowPins[4] = {11,10,9,8};
byte colPins[4] = {7,6,5,4};  
Keypad keypad(makeKeymap(keys), rowPins, colPins, ROWS, COLS);

const char* DEFAULT_PW="1234";
String inputBuffer="";
const unsigned long SENSOR_UPDATE_MS=300;
unsigned long t_sensor=0;
enum WindowState{WIDLE, OPENING, OPENED, CLOSING};
WindowState wstate=WIDLE;
bool ventilationActive=false;

const unsigned long OPEN_LABEL_MS=5000;
bool openLabelActive=false;
unsigned long openLabelEndAt_ms=0;

const unsigned long VENT_HOLD_MS=10000;
enum VentState{VENT_IDLE, VENT_OPENING, VENT_HOLD, VENT_CLOSING};
VentState vstate=VENT_IDLE;
unsigned long ventHoldEndAt_ms=0;

void lcdClearLine(uint8_t row){
  lcd.setCursor(0,row);
  for(int i=0;i<LCD_COLS;i++) 
    lcd.print(' ');
  lcd.setCursor(0,row);
}

void printFixed1(float v){
  long s=(long)(v*10.0f + (v>=0?0.5f:-0.5f));
  long ip=s/10; int dp=abs((int)(s%10));
  lcd.print(ip); lcd.print('.'); lcd.print(dp);
}

float readGasPPM(){
  int adc=analogRead(PIN_GAS);
  float v=(adc/1023.0f)*VCC; if(v<=0.05f) v=0.05f;
  float ratio=(RL*(VCC/v-1.0f))/R0;
  float ppm=A_coef*pow(ratio,B_coef);
  if(!isfinite(ppm)||ppm<0) ppm=0;
  return ppm;
}

float readHumidity(){
  int adc=analogRead(PIN_HUM);
  float vout=(adc/1023.0f)*VCC;
  float RH_lin=(vout/VCC - 0.16f)/0.0062f;
  float RH=RH_lin/(1.0546f - 0.00216f*25.0f);
  if(!isfinite(RH)) RH=0; 
  if(RH<0) RH=0; 
  if(RH>100) RH=100;
  return RH;
}

String statusText(){
  if(ventilationActive){
    if(vstate==VENT_HOLD) return "VENTILATING(45deg)";
    return "VENT";
  }
  switch(wstate){
    case OPENING: return "OPENING";
    case OPENED:  return openLabelActive ? "OPEN(90deg)" : "OPEN";
    case CLOSING: return "CLOSING";
    default:      return openLabelActive ? "OPEN(90deg)" : "READY";
  }
}

void refreshLCD(float gas,float hum){
  lcdClearLine(0); lcd.print("GAS: "); printFixed1(gas); lcd.print(" ppm");
  lcdClearLine(1); lcd.print("HUM: "); printFixed1(hum); lcd.print(" %");
  lcdClearLine(2);
  if(inputBuffer.length()){
    lcd.print("PW: "); lcd.print(inputBuffer.substring(0,16));
  }else{
    lcd.print("PW:0-9,D=Back,F=OK");
  }
  lcdClearLine(3); lcd.print("STATUS: "); lcd.print(statusText());
}

void startOpenManual(){
  wstate = OPENING;
  servoWindow.write(SERVO_OPEN_ANGLE_KEYPAD);
  wstate = OPENED;
}

void startOpenVent(){  
  wstate = OPENING;
  servoWindow.write(SERVO_OPEN_ANGLE_VENT);
  wstate = OPENED;
}

void startClose(){
  wstate = CLOSING;
  servoWindow.write(SERVO_CLOSE_ANGLE);
  wstate = WIDLE;
}

void startManualOpenLabel(){
  openLabelActive = true;
  openLabelEndAt_ms = millis() + OPEN_LABEL_MS;
}

void serviceManualOpenLabel(){
  if(openLabelActive && (long)(millis()-openLabelEndAt_ms)>=0){
    openLabelActive=false;
    if(wstate == OPENED){
      startClose();
    }
  }
}

void startVentCycle(){
  ventilationActive = true;
  vstate = VENT_OPENING;
  startOpenVent();
  vstate = VENT_HOLD;
  ventHoldEndAt_ms = millis() + VENT_HOLD_MS;
}

void serviceVentFSM(){
  switch(vstate){
    case VENT_IDLE: break;
    case VENT_OPENING:
      vstate=VENT_HOLD;
      ventHoldEndAt_ms=millis()+VENT_HOLD_MS;
      break;
    case VENT_HOLD:
      if((long)(millis()-ventHoldEndAt_ms)>=0){
        vstate=VENT_CLOSING;
        startClose();
      }
      break;
    case VENT_CLOSING:
      vstate=VENT_IDLE;
      ventilationActive=false;
      break;
  }
}

void handleKeypadFast(){
  keypad.setDebounceTime(5);
  keypad.setHoldTime(250);

  if(keypad.getKeys()){
    for(int i=0;i<LIST_MAX;i++){
      if(keypad.key[i].stateChanged && keypad.key[i].kstate==PRESSED){
        char k = keypad.key[i].kchar;

        if(k>='0' && k<='9'){
          if(inputBuffer.length()<16) inputBuffer+=k;
        }else if(k=='D'){
          if(inputBuffer.length()>0) inputBuffer.remove(inputBuffer.length()-1);
        }else if(k=='F'){
          if(inputBuffer.equals(DEFAULT_PW)){
            if(wstate==WIDLE && !ventilationActive){
              startOpenManual();
              startManualOpenLabel();
            }
          }
          inputBuffer="";
        }
      }
    }
  }
}

void setup(){
  Wire.begin();
  lcd.init(); lcd.backlight();

  servoWindow.attach(SERVO_PIN);
  servoWindow.write(SERVO_CLOSE_ANGLE);

  keypad.setDebounceTime(5);
  keypad.setHoldTime(250);

  Serial.begin(115200);
  t_sensor=0;

  refreshLCD(readGasPPM(), readHumidity());
  Serial.println(F("[SmartHome/Servo] Ready"));
}

void loop(){
  handleKeypadFast();
  serviceVentFSM();
  serviceManualOpenLabel();

  unsigned long now=millis();
  if(now - t_sensor >= SENSOR_UPDATE_MS){
    t_sensor = now;
    float gas=readGasPPM();
    float hum=readHumidity();
    if(!ventilationActive && wstate==WIDLE && gas>=GAS_THRESH_PPM){
      startVentCycle();
    }

    refreshLCD(gas,hum);
  }
}
```