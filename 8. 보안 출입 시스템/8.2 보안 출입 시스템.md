# 보안 출입 시스템 구현 
본 프로젝트는 RFID, 인체감지 센서, 서보모터, RGB LED를 결합하여 “허가된 사용자만 접근 가능한 스마트 도어락 시스템”을 구현하는 것을 목표로 합니다.

단순히 센서 하나를 제어하는 수준을 넘어서, 센서 간의 논리적 융합(인체 감지 + 태그 인증) 과
액추에이터(서보모터)를 통한 물리적 동작 제어, 그리고 LED를 이용한 시각적 피드백까지 통합한 실습 예제입니다.

## 구성 요소별 역할
### RFID
125kHz 대역의 RFID 태그를 인식하여 사용자의 ID를 확인합니다.
허용된 ID(3D00920EE5)와 일치할 경우에만 문이 열립니다.
ASCII 출력 모드에서 UART 통신(9600bps)을 통해 태그 ID를 MCU로 전송합니다.

### PIR
사람의 움직임을 감지하여 “최근 10초간 인체가 감지된 상태”를 기록합니다.
RFID 인증이 이 시간창 내에 이루어진 경우만 정상 출입으로 인정합니다.
인터럽트 기반으로 동작하여 다른 작업 중에도 감지를 놓치지 않습니다.

### 서보모터
인증 성공 시 문을 여닫는 물리적 장치 역할을 합니다.
일정 시간(기본 5초) 동안 개방된 뒤 자동으로 잠깁니다.
코드 내 상수(DOOR_OPEN_MS)로 개방 시간을 쉽게 조정할 수 있습니다.

### RGB LED
시스템 상태를 시각적으로 표시합니다.
| 상태 | LED 색상 | 의미 |
|:---:|:---:|:---|
| 잠김 | 🔴 빨강 | 기본 대기 상태 |
| 열림 | 🟢 초록 | 인증 성공, 문 개방 중 |
| 잘못된 태그 | 🟣 보라색 깜빡임 | 미허가 태그 감지, 3초간 경고 표시 |

## 동작 구조 
시스템은 아래의 흐름으로 동작합니다.

1. 대기(LOCKED)
    - 문이 잠긴 상태이며 LED는 빨간색입니다.
    - PIR 센서가 인체 움직임을 감지할 때까지 대기합니다.
2. 인체 감지(ARMED)
    - PIR 인터럽트가 발생하면 “최근 감지 시각”이 갱신됩니다.
    - 이후 10초 동안은 RFID 인증이 유효합니다.
3. RFID 인증(ACCESS)
    - RFID 모듈이 태그를 인식하면 ID 문자열을 읽습니다.
    - 태그가 허용 목록에 있으면 서보모터를 구동하여 문을 열고, LED를 초록색으로 변경합니다.
    - 다른 태그일 경우 LED를 보라색으로 3초간 점멸시켜 경고를 표시합니다.
4. 자동 잠금(LOCK RETURN)
    - 문이 열린 지 5초가 경과하면 자동으로 닫히고 LED가 다시 빨간색으로 바뀝니다.

## 하드웨어 연결 
<details> 
<summary><b>RFID 연결 정보 [Click]</b></summary>

| Pin | 연결 대상 | 설명 |
|:---:|:---:|:---|
| 5V | +5V | 전원 |
| GND | GND | 접지 |
| TX | 19 | UART TX |

</details>
<details> 
<summary><b>PIR 센서 연결 정보 [Click]</b></summary>

| Pin | 연결 대상 | 설명 |
|:---:|:---:|:---|
| 5V | +5V | 전원 |
| GND | GND | 접지 |
| 2 | D | Pir |

</details>

<details> <summary><b>서보모터 연결 정보 [Click]</b></summary>

| Pin | 연결 대상 | 설명 |
|:---:|:---:|:---|
| 5V | Red Cable | 전원 |
| GND | Brwon Cable | 접지 |
| 9 | Yellow Cable | Servo Motor PWM |

</details>

<details> <summary><b>RGB LED 연결 정보 [Click]</b></summary>

| Pin | 연결 대상 | 설명 |
|:---:|:---:|:---|
| GND | GND | 접지 |
| 10 | R | Red |
| 11 | G | Green |
| 12 | B | Blue |

</details>

## 프로그램 작성 
```arduino
#include <Servo.h>

#define RFID_SERIAL   Serial1

const uint8_t PIN_PIR = 2;
const uint8_t PIN_SERVO = 9;
const uint8_t PIN_LED_R = 10;
const uint8_t PIN_LED_G = 11;
const uint8_t PIN_LED_B = 12;
const char ALLOWED_TAG[] = "3D00920EE5"; 
unsigned long DOOR_OPEN_MS = 5000;
const unsigned long MOTION_WINDOW_MS = 10000;
const unsigned long WRONG_BLINK_MS = 3000;
const unsigned long BLINK_INTERVAL_MS = 200;

const int SERVO_LOCK_ANGLE = 0;
const int SERVO_OPEN_ANGLE = 90;

enum DoorState { LOCKED, OPENING, ALERT_WRONG };
DoorState state = LOCKED;

volatile bool pirTriggered = false;   
volatile unsigned long pirEdgeMs = 0; 
unsigned long lastMotionMs = 0;       

unsigned long openedAtMs = 0;         
unsigned long alertStartMs = 0;       
unsigned long lastBlinkMs = 0;        
bool blinkOn = false;                 

Servo door;

inline void ledWrite(uint8_t r, uint8_t g, uint8_t b) {
  analogWrite(PIN_LED_R, r);
  analogWrite(PIN_LED_G, g);
  analogWrite(PIN_LED_B, b);
}
inline void ledRed() { ledWrite(255, 0, 0); }
inline void ledGreen()  { ledWrite(0, 255, 0); }
inline void ledPurple() { ledWrite(180, 0, 200); }

inline void lockDoor() {
  door.write(SERVO_LOCK_ANGLE);
  state = LOCKED;
  ledRed();
}

inline void openDoor() {
  door.write(SERVO_OPEN_ANGLE);
  openedAtMs = millis();
  state = OPENING;
  ledGreen();
}

static inline uint8_t hex2nib(char c){
  if (c>='0'&&c<='9') 
    return (uint8_t)(c-'0');
  c = (char)toupper(c);
  if (c>='A'&&c<='F') 
    return (uint8_t)(10 + c - 'A');
  return 0;
}

static inline uint8_t hex2byte(char hi, char lo){
  return (uint8_t)((hex2nib(hi)<<4) | hex2nib(lo));
}

static bool verifyChecksum10hex(const char* id10, const char* cs2){
  uint8_t x = 0;
  for(int i=0;i<10;i+=2) 
    x ^= hex2byte(id10[i], id10[i+1]);
  return x == hex2byte(cs2[0], cs2[1]);
}

bool tryReadRFID(char* outTag10 /* size>=11 */){
  static enum {WAIT_STX, READ_ID, READ_CS, READ_CR, READ_LF, READ_ETX} st = WAIT_STX;
  static char id10[10];
  static char cs2[2];
  static uint8_t idx = 0;
  static unsigned long t0 = 0;
  const unsigned long FRAME_TO = 50;

  auto reset_state = [&](){
    st = WAIT_STX; idx = 0;
  };

  while (RFID_SERIAL.available()){
    int b = RFID_SERIAL.read();
    if (st == WAIT_STX){
      if (b == 0x02){ st = READ_ID; idx = 0; t0 = millis(); }
      continue;
    }
    if (millis() - t0 > FRAME_TO){ reset_state(); continue; }

    if (st == READ_ID){
      id10[idx++] = (char)b;
      if (idx >= 10){ st = READ_CS; idx = 0; }
    } else if (st == READ_CS){
      cs2[idx++] = (char)b;
      if (idx >= 2){ st = READ_CR; }
    } else if (st == READ_CR){
      if (b != '\r'){ reset_state(); continue; }
      st = READ_LF;
    } else if (st == READ_LF){
      if (b != '\n'){ reset_state(); continue; }
      st = READ_ETX;
    } else if (st == READ_ETX){
      if (b != 0x03){
      }
      if (!verifyChecksum10hex(id10, cs2)){ reset_state(); return false; }
      for (int i=0;i<10;i++) outTag10[i] = (char)toupper(id10[i]);
      outTag10[10] = '\0';
      Serial.print(F("[RFID] TAG=")); Serial.print(outTag10);
      Serial.print(F(" CS=")); Serial.write(cs2,2);
      Serial.println(F(" OK"));

      reset_state();
      return true;
    }
  }
  return false;
}

void pirISR() {
  pirTriggered = true;
  pirEdgeMs = millis();
}

void setup() {
  pinMode(PIN_LED_R, OUTPUT);
  pinMode(PIN_LED_G, OUTPUT);
  pinMode(PIN_LED_B, OUTPUT);
  ledRed();

  door.attach(PIN_SERVO);
  lockDoor();

  pinMode(PIN_PIR, INPUT);
  attachInterrupt(digitalPinToInterrupt(PIN_PIR), pirISR, CHANGE);

  RFID_SERIAL.begin(9600);
  Serial.begin(115200);
  Serial.println(F("[System] Ready (RFID+PIR+Servo+RGB)"));
  Serial.print(F("Allowed TAG: "));
  Serial.println(ALLOWED_TAG);
}

void loop() {
  unsigned long now = millis();
  if (pirTriggered) {
    pirTriggered = false;
    static unsigned long lastPirEdge = 0;
    if (now - lastPirEdge > 100) {
      lastPirEdge = now;
      if (digitalRead(PIN_PIR) == HIGH) {
        lastMotionMs = now;
        if (state == LOCKED) {
          Serial.println(F("[PIR] Motion detected (window refreshed)"));
        }
      }
    }
  }

  char tag[11];
  if (tryReadRFID(tag)) {
    Serial.print(F("[RFID] TAG: "));
    Serial.println(tag);

    bool inMotionWindow = (now - lastMotionMs) <= MOTION_WINDOW_MS;
    if (inMotionWindow) {
      if (strcmp(tag, ALLOWED_TAG) == 0) {
        if (state != OPENING) {
          openDoor();
          Serial.println(F("[ACCESS] Granted -> Door OPEN"));
        }
      } else {
        alertStartMs = now;
        lastBlinkMs = 0;
        blinkOn = false;
        state = ALERT_WRONG;
        Serial.println(F("[ACCESS] DENIED (wrong TAG)"));
      }
    } else {
      alertStartMs = now;
      lastBlinkMs = 0;
      blinkOn = false;
      state = ALERT_WRONG;
      Serial.println(F("[ACCESS] DENIED (no recent motion)"));
    }
  }

  if (state == OPENING) {
    if (now - openedAtMs >= DOOR_OPEN_MS) {
      lockDoor();
      Serial.println(F("[Door] Auto LOCK"));
    }
  } else if (state == ALERT_WRONG) {
    if (now - alertStartMs <= WRONG_BLINK_MS) {
      if (now - lastBlinkMs >= BLINK_INTERVAL_MS) {
        lastBlinkMs = now;
        blinkOn = !blinkOn;
        if (blinkOn) 
          ledPurple();
        else 
          ledWrite(0, 0, 0); 
      }
    } else {
      if (state != LOCKED) {
        lockDoor(); 
      }
    }
  }
}
```