# TextLCD
## TextLCD
Text LCD는 문자 전용 LCD 모듈로, 일반적으로 16×2(16자 × 2줄) 또는 20×4(20자 × 4줄) 형태가 많이 사용됩니다. 내장된 HD44780 호환 컨트롤러를 통해 아스키 코드 문자, 숫자, 기호를 화면에 표시할 수 있으며, 일부 영역에는 사용자가 정의한 커스텀 문자(Custom Character)도 출력할 수 있습니다.

Text LCD의 구동 방식은 크게 8비트 모드와 4비트 모드가 있습니다.

8비트 모드는 데이터 라인 8개(D0~D7)를 모두 사용하여 명령어 및 데이터를 전송하는 방식으로, 처리 속도가 빠르지만 많은 핀이 필요합니다.

4비트 모드는 상위 데이터 라인 4개(D4~D7)만을 사용하여 두 번에 나누어 전송하는 방식으로, 핀 수를 줄일 수 있다는 장점이 있습니다. 아두이노 등 소형 MCU에서는 주로 4비트 모드를 사용합니다.

TextLCD에는 RS, RW, E 제어 핀이 존재합니다.

- RS(Register Select): 명령어 전송인지, 문자 데이터 전송인지를 선택
- RW(Read/Write): 읽기/쓰기를 구분 (일반적으로 GND로 고정하여 쓰기 전용으로 사용)
- E(Enable): 신호를 유효하게 만드는 클럭 역할

이외에 V0(대비 조절 핀)을 통해 문자 선명도를 조절할 수 있으며, 백라이트 전원 단자를 통해 화면 가독성을 높일 수 있습니다.

Text LCD는 단순히 문자만 출력할 수 있지만, 여러 줄의 정보(예: 센서 값, 시간, 상태 메시지 등)를 직관적으로 보여줄 수 있어 임베디드 시스템에서 널리 활용됩니다. 특히 조작 버튼이나 센서 데이터와 함께 사용하면 간단한 HMI(Human-Machine Interface) 역할을 수행할 수 있습니다.

## TextLCD 제어 명령

| 명령 | 코드(HEX) | 비트 구조 | 기능 |
| :--- | :--- | :--- | :--- |
| Clear Display | 0x01 | — | 화면 전체 클리어, 커서 홈(0,0) |
| Return Home | 0x02 | — | 커서 홈, 표시 쉬프트 해제 |
| Entry Mode Set | 0x04~0x07 | 0b000001IS | I: Inc/Dec(1=증가), S: Shift(1=Shift) |
| Display On/Off Control | 0x08~0x0F | 0b00001DCB | D: Display, C: Cursor, B: Blink |
| Cursor/Display Shift | 0x10~0x1F | 0b0001SRxx | S/C(1=Display,0=Cursor), R/L(1=Right) |
| Function Set | 0x20~0x3F | 0b001DLNFx | DL: 8/4비트, N: 2/1라인, F: 5×10/5×8 |
| Set CGRAM Address | 0x40~0x7F | 0b01xxxxxx | 커스텀 문자(CGRAM) 주소 설정 |
| Set DDRAM Address | 0x80~0xFF | 0b1xxxxxxx | 화면 위치(DDRAM) 주소 설정 |


![TextLCD Schematic](res/TextLCD%20Schematic.png)

## TextLCD 연결 
| Pin | 연결 대상 | 설명 |
|:---:|:---:|:---|
| 5V | +5V | 전원 |
| GND | GND | 접지 |
| 20 | C | I2C Clock |
| 21 | D | I2C Data |

## TextLCD 제어 
TextLCD 에 간단한 문자를 출력하는 예제 입니다. setCursor()를 통해 커서의 위치를 조정하고 print() 를 통해 TextLCD에 문자를 출력합니다. clear()는 화면에 출력된 문자를 지우는 역할을 담당합니다. 

```cpp
#include <Wire.h>
#include <LiquidCrystal_I2C.h>

#define LCD_ADDR   0x27   
#define LCD_COLS   20
#define LCD_ROWS   4
#define PERIOD_MS  500UL 

LiquidCrystal_I2C lcd(LCD_ADDR, LCD_COLS, LCD_ROWS);

unsigned long lastTick = 0;
uint32_t counter = 0; 

void setup() {
  Wire.begin();         
  lcd.init();
  lcd.backlight();
  lcd.clear();
}

void loop() {
  lcd.setCursor(0, 0);
  lcd.print("Hello");
  lcd.setCursor(2, 1);
  lcd.print("World!");  
  lcd.setCursor(4, 2);
  lcd.print("TextLCD");
  lcd.setCursor(6, 3);
  lcd.print("Initialized!");  
  delay(3000);
  lcd.clear();
  delay(1500);
}
```

### Progress Bar 
앞서와 같이 TextLCD에 문자를 출력합니다. 앞의 예제와 다르게 시간에 따라서 진행상황을 표기하는 바를 만들어 출력합니다. 출력 방향은 행에 따라서 다릅니다. 

```cpp
#include <Wire.h>
#include <LiquidCrystal_I2C.h>

#define LCD_ADDR    0x27
#define LCD_COLS    20
#define LCD_ROWS    4
#define STEP_MS     100UL 
#define PAUSE_MS    2000UL

LiquidCrystal_I2C lcd(LCD_ADDR, LCD_COLS, LCD_ROWS);

unsigned long lastStep   = 0;
unsigned long pauseStart = 0;

uint8_t curRow  = 1;
uint8_t stepIdx = 0;
bool isPause    = false;

void drawHeader() {
  lcd.setCursor(0, 0);
  lcd.print("Progress Bar        ");
}

void clearProgressArea() {
  for (uint8_t r = 1; r < LCD_ROWS; ++r) {
    lcd.setCursor(0, r);
    lcd.print("                    ");
  }
}

void resetProgress() {
  clearProgressArea();
  curRow  = 1;
  stepIdx = 0;
}

void setup() {
  Wire.begin();
  lcd.init();
  lcd.backlight();
  drawHeader();
  resetProgress();
}

void loop() {
  unsigned long now = millis();

  if (isPause) {
    if (now - pauseStart >= PAUSE_MS) {
      isPause = false;
      resetProgress();
      lastStep = now; 
    }
    return;
  }

  if (now - lastStep >= STEP_MS) {
    lastStep += STEP_MS;

    if (curRow == 1) {
      if (stepIdx < LCD_COLS) {
        lcd.setCursor(stepIdx, 1);
        lcd.print('#');
        stepIdx++;
      }
      if (stepIdx >= LCD_COLS) { curRow = 2; stepIdx = 0; }

    } else if (curRow == 2) {
      if (stepIdx < LCD_COLS) {
        uint8_t col = (LCD_COLS - 1) - stepIdx;
        lcd.setCursor(col, 2);
        lcd.print('#');
        stepIdx++;
      }
      if (stepIdx >= LCD_COLS) { curRow = 3; stepIdx = 0; }

    } else {
      uint8_t half = LCD_COLS / 2;
      int8_t left = (half - 1) - stepIdx;
      int8_t right = (half) + stepIdx;

      if (left >= 0) {
        lcd.setCursor(left, 3);
        lcd.print('#');
      }
      if (right < LCD_COLS) {
        lcd.setCursor(right, 3);
        lcd.print('#');
      }

      stepIdx++;
      if (stepIdx >= half) {
        isPause = true;
        pauseStart = now;
      }
    }
  }
}
```

### 센서 모니터링 
가스 센서와 습도 센서의 값을 TextLCD를 통해 출력해보겠습니다. 10ms 마다 센서의 값을 읽어 출력하며, 추가로 구동된 시간도 함께 출력합니다. 

각센서 핀연결은 다음과 같습니다. 

#### TextLCD 
| Pin | 연결 대상 | 설명 |
|:---:|:---:|:---|
| 5V | +5V | 전원 |
| GND | GND | 접지 |
| 20 | C | I2C Clock |
| 21 | D | I2C Data |

#### Gas Sensor 
| Pin | 연결 대상 | 설명 |
|:---:|:---:|:---|
| 5V | +5V | 전원 |
| GND | GND | 접지 |
| A2 | A | Gas Sensor |

#### Humidity Sensor 
| Pin | 연결 대상 | 설명 |
|:---:|:---:|:---|
| 5V | +5V | 전원 |
| GND | GND | 접지 |
| A3 | A | Humidity Sensor |

```cpp
#include <LiquidCrystal_I2C.h>

#define LCD_ADDR 0x27
#define LCD_COLS 20
#define LCD_ROWS 4

#define GAS_PIN A2
#define HUM_PIN A3

LiquidCrystal_I2C lcd(LCD_ADDR, LCD_COLS, LCD_ROWS);

unsigned long now = 0;

String hhmmss(unsigned long ms) {
  unsigned long s = ms / 1000;
  unsigned int h = s / 3600;
  unsigned int m = (s % 3600) / 60;
  unsigned int sec = s % 60;
  char buf[16];
  snprintf(buf, sizeof(buf), "%02u:%02u:%02u", h, m, sec);
  return String(buf);
}

void setup() {
  lcd.init();
  lcd.backlight();
  lcd.clear();
  now = millis();
}

void loop() {
  if(millis() - now > 500) {
    int gasValue = analogRead(GAS_PIN);
    int humValue = analogRead(HUM_PIN);
    lcd.setCursor(0, 0);
    lcd.print("Gas: ");
    lcd.print(gasValue);

    lcd.setCursor(0, 1);
    lcd.print("Hum: ");
    lcd.print(humValue);

    lcd.setCursor(0, 2);
    lcd.print("                    ");
    now = millis();
  }

  lcd.setCursor(0, 3);
  lcd.print("Uptime ");
  lcd.print(hhmmss(millis()));

  delay(10);
}
```