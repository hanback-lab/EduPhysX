# 4Digit FND
## 4Digit FND
4Digit FND는 한 자리에 7개의 LED 세그먼트(가로·세로 바 형태)와 소수점 표시용 점(·)을 포함한 Seven Segment Display가 4자리 묶음으로 구성된 표시 장치입니다. 각 세그먼트 LED의 조합을 통해 숫자(0~9) 또는 일부 알파벳을 표시할 수 있습니다.

구성 방식에는 공통 애노드(Common Anode) 와 공통 캐소드(Common Cathode) 두 가지가 있습니다.

공통 애노드형은 각 자리의 애노드 단자가 서로 묶여 VCC에 연결되고, 원하는 세그먼트의 캐소드에 전류를 흘려 점등합니다.

공통 캐소드형은 각 자리의 캐소드 단자가 묶여 GND에 연결되며, 원하는 세그먼트의 애노드에 전압을 인가하여 점등합니다.

4자리 구조의 경우 모든 세그먼트를 독립적으로 제어하기에는 핀 수가 많아집니다. 이를 해결하기 위해 일반적으로 **자리 단위 공통 단자(Digit Select)** 를 두고, 7세그먼트 데이터 신호는 모든 자리에서 공통으로 사용합니다. 원하는 숫자를 표시할 때는 특정 자리의 공통 단자를 활성화한 후 해당 자리의 세그먼트 데이터를 출력하고, 이후 매우 빠른 속도로 다른 자리로 전환하는 다중화(Multiplexing) 방식을 사용합니다. 사람의 눈에는 이러한 빠른 전환이 잔상 효과로 인해 동시에 모든 자리가 점등된 것처럼 보이게 됩니다.

이 방식의 장점은 적은 수의 핀으로 여러 자리의 숫자를 표현할 수 있다는 점이며, 가격이 저렴하고 제어가 단순하여 임베디드 시스템에서 널리 활용됩니다. 다만 다중화 주기가 너무 느리면 깜박임이 발생하고, 너무 빠르면 MCU의 처리 부하가 증가하는 단점이 있습니다.

4Digit FND는 일반적으로 시계(시간 표시), 카운터, 온도/습도계 표시 장치, 가전제품(예: 전자레인지, 전기밥솥) 등에서 널리 사용되고 있습니다.

![FND]()

![FND Schematic](res/FND%20Schematic.png)

FND 는 GPIO를 연결해서 제어하기도 합니다. GPIO를 연결하는 경우에 자리를 선택하는 GPIO와 표기를 위한 GPIO까지 4Digit 의 경우 총 12(4+8)개의 GPIO가 필요합니다. 하지만 전용 IC를 활용하면 I2C 통신을 통해 2개의 핀만 연결하여 회로 구성을 좀더 간편하게 할 수 있습니다. 

### HT16K33 초기화 명령 

| 명령(예시) | 설명 |
| :--- | :--- |
| 0x21 | Oscillator ON (내부 오실레이터 켜기) |
| 0x81 | Display ON + Blink OFF  0x80 \| 0x01 \| (0<<1) |
| 0x83 | Display ON + Blink 2 Hz |
| 0x85 | Display ON + Blink 1 Hz |
| 0x87 | Display ON + Blink 0.5 Hz |
| 0xE0 | n | 밝기(0~15), n=0x00~0x0F (15가 최대로 밝음) |

### HT16K33 세그먼트 비트 
HT16K33 의 레지스터에 8비트 데이터를 통해서 각 FND의 켜고 끄는 제어가 가능합니다. 
레지스터 주소는 다음과 같습니다. 
| 주소 | 설명 |
| :--- | :--- |
| 0x00 | Digit0 |
| 0x02 | Digit1 |
| 0x04 | Digit2 |
| 0x06 | Digit3 |


주소와 함께 8비트 데이터를 전달하면 값에 따라 켜고 끄는것이 가능합니다. 
| bit7 | bit6 | bit5 | bit4 | bit3 | bit2 | bit1 | bit0 |
|:---|:---|:---|:---|:---|:---|:---|:---|
| dp | g | f | e | d | c | b | a | 

![FND location](res/FND%20LED%20location.png)

## 4Digit FND 연결 

| Pin | 연결 대상 | 설명 |
|:---:|:---:|:---|
| 5V | +5V | 전원 |
| GND | GND | 접지 |
| 20 | C | I2C Clock |
| 21 | D | I2C Data |

## 4Digit FND 제어 
처음 FND 제어 코드는 0~9까지 숫자를 4자리에 모두 같은 숫자를 출력하는 코드입니다. 

```cpp
#include <Wire.h>

#define HT16K33 0x70

uint8_t digitMap[10] = {
  0b00111111, 
  0b00000110, 
  0b01011011, 
  0b01001111, 
  0b01100110, 
  0b01101101, 
  0b01111101, 
  0b00000111, 
  0b01111111, 
  0b01101111
};

void ht16k33_write(uint8_t addr, uint8_t data) {
  Wire.beginTransmission(HT16K33);
  Wire.write(addr);
  Wire.write(data);
  Wire.endTransmission();
}

void displayDigit(int pos, int num) {
  uint8_t addr = pos * 2;
  ht16k33_write(addr, digitMap[num]);
}

void setup() {
  Wire.begin();
  Wire.beginTransmission(HT16K33);
  Wire.write(0x21);
  Wire.endTransmission();
  Wire.beginTransmission(HT16K33);
  Wire.write(0x81);
  Wire.endTransmission();
  Wire.beginTransmission(HT16K33);
  Wire.write(0xE0 | 0x0F);
  Wire.endTransmission();
}

void loop() {
  for(int i=0;i<10;i++){
    displayDigit(3, i);
    displayDigit(2, i);
    displayDigit(1, i);
    displayDigit(0, i);
    delay(300);
  }
}
```

## FND Counter
이번에는 10ms 마다 카운트 하여 숫자가 카운트 되도록 코드를 작성합니다. 

```cpp
#include <Wire.h>

#define HT16K33 0x70

uint8_t digitMap[10] = {
  0b00111111, 
  0b00000110, 
  0b01011011, 
  0b01001111, 
  0b01100110, 
  0b01101101, 
  0b01111101, 
  0b00000111, 
  0b01111111, 
  0b01101111
};

void ht16k33_write(uint8_t addr, uint8_t data) {
  Wire.beginTransmission(HT16K33);
  Wire.write(addr);
  Wire.write(data);
  Wire.endTransmission();
}

void displayDigit(int pos, int num) {
  uint8_t addr = pos * 2;
  ht16k33_write(addr, digitMap[num]);
}

void setup() {
  Wire.begin();
  Wire.beginTransmission(HT16K33);
  Wire.write(0x21);
  Wire.endTransmission();
  Wire.beginTransmission(HT16K33);
  Wire.write(0x81);
  Wire.endTransmission();
  Wire.beginTransmission(HT16K33);
  Wire.write(0xE0 | 0x0F);
  Wire.endTransmission();
}

void loop() {
  static int n = 0;
  int d1 = (n / 1) % 10;
  int d2 = (n / 10) % 10;
  int d3 = (n / 100) % 10;
  int d4 = (n / 1000) % 10;

  displayDigit(3, d1);
  displayDigit(2, d2);
  displayDigit(1, d3);
  displayDigit(0, d4);

  n++;
  if(n > 9999) 
    n = 0;
  delay(10);
}
```

## STOPWATCH 
앞서 작성한 코드를 기반으로 스탑워치 기능을 구현해 보겠습니다. 스위치 눌림에 따라 카운트를 시작하고 같은 버튼을 눌렀을때 정지합니다. 시간이 정지된 상태에서 같은 버튼을 누르면 시간 카운트가 계속되며, 정지된 상태에서 다른 스위치를 누르게 되면 0 으로 초기화 됩니다. 

4Digit FND 와 푸쉬 스위치 모듈을 활용하며 핀 연결은 다음과 같습니다. 

| Pin | 연결 대상 | 설명 |
|:---:|:---:|:---|
| 5V | +5V | 전원 |
| GND | GND | 접지 |
| 20 | C | I2C Clock |
| 21 | D | I2C Data |

| Pin | 연결 대상 | 설명 |
|:---:|:---:|:---|
| 5V | +5V | 전원 |
| GND | GND | 접지 |
| 8 | SW0 | Switch 0 |
| 9 | SW1 | Switch 1 |

```cpp
#include <Wire.h>

#define HT16K33_ADDR 0x70

#define BTN_ACTIVE_HIGH 1
#define BOOT_GRACE_MS 200

#define LIMIT_BEHAVIOR_STOP 0
#define LIMIT_BEHAVIOR_WRAP 1
#define LIMIT_BEHAVIOR LIMIT_BEHAVIOR_STOP

const uint8_t DIGIT_MAP[10] = {
  0b00111111,0b00000110,0b01011011,0b01001111,0b01100110,
  0b01101101,0b01111101,0b00000111,0b01111111,0b01101111
};

inline void ht16k33Write(uint8_t addr, uint8_t data){
  Wire.beginTransmission(HT16K33_ADDR);
  Wire.write(addr); Wire.write(data);
  Wire.endTransmission();
}

void displayDigit(uint8_t pos, uint8_t num, bool dpOn=false){
  if(pos>3) 
    return;
  uint8_t v = DIGIT_MAP[num & 0x0F];
  if(dpOn) 
    v |= 0x80;
  ht16k33Write(pos*2, v);
}

void clearDisplay(){
  for(uint8_t i=0;i<4;++i) 
    ht16k33Write(i*2, 0x00);
}

void displaySSss(uint32_t elapsedMs){
  if(elapsedMs>99990) elapsedMs=99990;
  uint16_t centi = elapsedMs/10;
  uint8_t s10 = (centi/1000)%10;   
  uint8_t s1 = (centi/100)%10;
  uint8_t cs10 = (centi/10)%10;
  uint8_t cs1 = (centi/1)%10;

  displayDigit(0, s10, false);
  displayDigit(1, s1, true);
  displayDigit(2, cs10, false);
  displayDigit(3, cs1, false);
}

struct Btn{
  uint8_t pin;
  bool lastStable;
  bool lastRead;
  unsigned long lastChangeMs;
};

Btn bStartStop{8, true, true, 0};
Btn bReset{9, true, true, 0};

bool readPressEdge(Btn& b, unsigned long now, unsigned long debounceMs=20){
  bool r = digitalRead(b.pin);
  if(r != b.lastRead){ 
    b.lastRead = r; 
    b.lastChangeMs = now; 
  }
  if((now - b.lastChangeMs) > debounceMs && r != b.lastStable){
    b.lastStable = r;
#if BTN_ACTIVE_HIGH
    if(r == HIGH) return true;
#else
    if(r == LOW)  return true;
#endif
  }
  return false;
}

enum State { IDLE, RUNNING, PAUSED };
State state = IDLE;
unsigned long startMs = 0, accumMs = 0;
unsigned long bootMs = 0;

void setup(){
  Wire.begin();
  Wire.beginTransmission(HT16K33_ADDR); Wire.write(0x21); Wire.endTransmission();
  Wire.beginTransmission(HT16K33_ADDR); Wire.write(0x81); Wire.endTransmission();
  Wire.beginTransmission(HT16K33_ADDR); Wire.write(0xE0|0x0F); Wire.endTransmission();

#if BTN_ACTIVE_HIGH
  pinMode(bStartStop.pin, INPUT);
  pinMode(bReset.pin, INPUT);
#else
  pinMode(bStartStop.pin, INPUT_PULLUP);
  pinMode(bReset.pin, INPUT_PULLUP);
#endif

  bootMs = millis();

  clearDisplay();
  displaySSss(0);
}

void loop(){
  unsigned long now = millis();
  bool allowButtons = (now - bootMs) > BOOT_GRACE_MS;

  bool startStopEdge = allowButtons ? readPressEdge(bStartStop, now) : false;
  bool resetEdge     = allowButtons ? readPressEdge(bReset,     now) : false;

  if(startStopEdge){
    if(state == IDLE){
      accumMs = 0;
      startMs = now;
      state = RUNNING;
    } else if(state == RUNNING){
      accumMs += (now - startMs);
      state = PAUSED;
    } else if(state == PAUSED){
      startMs = now;
      state = RUNNING;
    }
  }

  if(resetEdge && state == PAUSED){
    accumMs = 0;
    state = IDLE;
  }

  unsigned long elapsedMs = (state == RUNNING) ? (accumMs + (now - startMs)) : accumMs;

  if(elapsedMs >= 100000){
#if (LIMIT_BEHAVIOR == LIMIT_BEHAVIOR_STOP)
    elapsedMs = 99990; 
    accumMs   = 99990; 
    state     = PAUSED;
#elif (LIMIT_BEHAVIOR == LIMIT_BEHAVIOR_WRAP)
    elapsedMs = 0;
    accumMs   = 0;
    startMs   = now;
#endif
  }

  displaySSss(elapsedMs);
  delay(10);
}
```