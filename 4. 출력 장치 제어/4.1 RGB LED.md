# RGB LED 
## RGB LED
LED를 이용하여 색상을 표현할 때에는 단일 색상의 LED만으로는 원하는 모든 색을 구현하기 어렵습니다. 따라서 Red, Green, Blue LED의 조합을 통해 다양한 색을 표현하게 되며, 이를 위해 각 색상의 LED 밝기를 정밀하게 제어하는 기술이 필요합니다.

가장 기본적인 방식은 단색 LED(Red, Green, Blue)를 근접 배치하고, 각각의 밝기를 조절하여 색을 합성하는 방법입니다. 이 방식은 일반 LED를 사용하므로 구현이 용이하고, 개별 LED의 고장 여부를 쉽게 확인할 수 있으며 가격이 저렴하다는 장점이 있습니다. 그러나 LED 간 간격이 넓고 구성 면적이 크기 때문에, 사용자가 가까운 거리에서 관찰할 경우 색상이 분리되어 보이고 혼합 효과가 충분히 발휘되지 않는 단점이 있습니다. 이러한 이유로 주로 실외 전광판에 활용됩니다.

반면, RGB LED는 하나의 소자 안에 Red, Green, Blue가 모두 포함된 구조로, 일반적으로 3색 LED 모듈이라고 부릅니다. 이 방식은 크기가 작고 색 혼합도가 높아 가까운 거리에서도 자연스러운 색상을 구현할 수 있다는 장점이 있습니다. 그러나 일반 LED에 비해 가격이 높으며, 한 색상의 LED가 손상될 경우 모듈 전체를 교체해야 하는 단점이 있습니다. 이러한 특성으로 인해 주로 실내용 전광판이나 근거리 표시 장치에 사용됩니다.

빨강, 초록, 파랑은 빛의 3원색으로 불리며, 이들을 조합하여 다양한 색상을 만들어 낼 수 있습니다. 예를 들어 세 가지 색이 모두 합쳐지면 흰색이 됩니다. 이때 주의하실 점은, 물감과 같은 색의 혼합은 감산 혼합으로 섞을수록 어두워져 검정색에 가까워지는 반면, 빛의 혼합은 가산 혼합이라 하여 섞을수록 밝아져 흰색이 된다는 점입니다.

![RGBLED Schematic](res/RGB%20LED%20Schematic.png)

## RGB LED 연결 

| Pin | 연결 대상 | 설명 |
|:---:|:---:|:---|
| GND | GND | 접지 |
| 9 | R | Red |
| 10 | G | Green |
| 11 | B | Blue |

## RGB LED 제어 
세 색상(R/G/B)을 차례로 0~255까지 PWM으로 증가시켜 밝아지는 정도를 확인하는 예제입니다.
analogWrite() 함수로 각 색의 밝기를 개별 제어하며, PWM의 듀티비가 빛의 세기를 결정합니다.

```cpp
int pin_r = 9, pin_g = 10, pin_b = 11;
int i = 0;

void setup(){ 
    pinMode(pin_r,OUTPUT); 
    pinMode(pin_g,OUTPUT); 
    pinMode(pin_b,OUTPUT); 
    analogWrite(pin_r,0);
    analogWrite(pin_g,0);
    analogWrite(pin_b,0);
}

void loop(){
  for(i=0;i<255;i++){
    analogWrite(pin_r,i);
    delay(20);
  }
  analogWrite(pin_r,0);
  for(i=0;i<255;i++){
    analogWrite(pin_g,i);
    delay(20);
  }
  analogWrite(pin_g,0);
  for(i=0;i<255;i++) {
    analogWrite(pin_b,i);
    delay(20);
  }
  analogWrite(pin_b,0);
}
```

색상각(Hue)을 0~360도로 순환시키며, HSV 모델을 이용해 부드러운 색상 변화를 만듭니다.
COMMON_ANODE 변수를 통해 공통 애노드형 LED에서도 정상 작동하도록 PWM 값을 반전 처리합니다. 

```cpp
uint8_t pin_r = 9, pin_g = 10, pin_b = 11;
bool COMMON_ANODE = false;
float hue=0;

inline uint8_t c255(int v){ return v<0?0:(v>255?255:v); }

void hsv2rgb(float h,float s,float v,uint8_t& r,uint8_t& g,uint8_t& b){
  float c=v*s, x=c*(1-fabs(fmod(h/60.0,2)-1)), m=v-c, rr,gg,bb;
  if(h<60){
    rr=c;
    gg=x;
    bb=0;
  } else if(h<120){
    rr=x;
    gg=c;
    bb=0;
  } else if(h<180){
    rr=0;
    gg=c;
    bb=x;
  } else if(h<240){
    rr=0;
    gg=x;
    bb=c;
  } else if(h<300){
    rr=x;
    gg=0;
    bb=c;
  } else {
    rr=c;
    gg=0;
    bb=x;
  }
  r=c255((rr+m)*255); 
  g=c255((gg+m)*255); 
  b=c255((bb+m)*255);
}

void writeRGB(uint8_t r,uint8_t g,uint8_t b){
  if(COMMON_ANODE){ 
    r=255-r; 
    g=255-g; 
    b=255-b; 
  }
  analogWrite(pin_r,r); 
  analogWrite(pin_g,g); 
  analogWrite(pin_b,b);
}

void setup(){ 
  pinMode(pin_r,OUTPUT); 
  pinMode(pin_g,OUTPUT); 
  pinMode(pin_b,OUTPUT); 
}

void loop(){
  uint8_t r,g,b; 
  hsv2rgb(hue,1.0,1.0,r,g,b); 
  writeRGB(r,g,b);
  hue+=0.8; 
  if(hue>=360) 
    hue-=360; 
  delay(10);
}
```

## 밝기에 따른 색상 변화 
조도센서로 읽은 밝기 값(0 ~ 1023)을 Hue(0 ~ 359) 범위에 매핑하여 색상이 자연스럽게 바뀝니다.
밝을수록 색이 차갑게, 어두울수록 따뜻하게 변화하는 효과를 실험할 수 있습니다.

| Pin | 연결 대상 | 설명 |
|:---:|:---:|:---|
| GND | GND | 접지 |
| 9 | R | Red |
| 10 | G | Green |
| 11 | B | Blue |

| Pin | 연결 대상 | 설명 |
|:---:|:---:|:---|
| 5V | +5V | 전원 |
| GND | GND | 접지 |
| A0 | A | Light Sensor |

```cpp
int pin_light = A0, pin_r = 9, pin_g = 10, pin_b = 11;

void hsv2rgb(uint16_t h, uint8_t s, uint8_t v, uint8_t &r, uint8_t &g, uint8_t &b) {
  if (s == 0) { r = g = b = v; return; }
  float hf = (h % 360) / 60.0;
  int i = (int)hf;
  float f = hf - i;
  float sv = s / 255.0;
  float pv = v * (1.0 - sv);
  float qv = v * (1.0 - sv * f);
  float tv = v * (1.0 - sv * (1.0 - f));
  float rf, gf, bf;
  switch (i) {
    case 0: rf = v;  gf = tv; bf = pv; break;
    case 1: rf = qv; gf = v;  bf = pv; break;
    case 2: rf = pv; gf = v;  bf = tv; break;
    case 3: rf = pv; gf = qv; bf = v;  break;
    case 4: rf = tv; gf = pv; bf = v;  break;
    default: rf = v; gf = pv; bf = qv; break;
  }
  r = (uint8_t)rf; g = (uint8_t)gf; b = (uint8_t)bf;
}

void setup() {
  pinMode(pin_r, OUTPUT);
  pinMode(pin_g, OUTPUT);
  pinMode(pin_b, OUTPUT);
  pinMode(pin_light,INPUT);
}

void loop() {
  int adc = analogRead(pin_light);
  uint16_t h = map(adc, 0, 1023, 0, 359);
  uint8_t s = 255;
  uint8_t v = 255;
  uint8_t r, g, b;
  hsv2rgb(h, s, v, r, g, b);
  analogWrite(pin_r, r);
  analogWrite(pin_g, g);
  analogWrite(pin_b, b);
  delay(20);
}
```
