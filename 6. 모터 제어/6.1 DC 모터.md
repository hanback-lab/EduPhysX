# DC 모터
## DC 모터
DC 모터는 고정자로 영구자석을, 회전자(전기자)로 코일을 사용하여 구성한 모터입니다. 전기자에 흐르는 전류의 방향을 전환함으로써 자력의 흡인력과 반발력을 발생시켜 회전력을 얻을 수 있습니다.
이러한 구조적 특징으로 인해 DC 모터는 모형 자동차, 무선 조종 장난감 등 다양한 소형 전동 장치에 널리 사용되고 있으며, 로봇 분야에서는 이동 로봇의 바퀴 구동부로 주로 활용됩니다.

### DC 모터 특징
- 기동 토크가 크며 정지 상태에서 쉽게 회전할 수 있습니다.
- 인가 전압과 회전 속도가 직선적으로 비례합니다.
- 입력 전류와 출력 토크가 직선적으로 비례하여 출력 효율이 우수합니다.
- 가격이 저렴하여 범용적으로 사용할 수 있습니다.
- 제어 회로가 단순하여 구현이 용이합니다.
- 단점으로는 브러시(brush)와 정류자(commutator)를 통한 기계식 접점 때문에 스파크 발생, 회전 소음, 수명 단축 문제가 존재합니다.

### DC 모터 구조 
DC 모터는 크게 전기자(Armature), 영구자석(Permanent Magnet), 브러시(Brush), 정류자(Commutator), 베어링, 모터 케이스 등으로 구성됩니다.

- 브러시(Brush) : 전기자에 전류를 공급하는 접점 장치
- 정류자(Commutator) : 권선에 전류를 순차적으로 공급하는 전환 장치
- 전기자(Armature) : 회전력을 발생시키는 전자석이며, 회전체를 구성
- 베어링(Bearing) : 회전축을 지지하며, 볼 베어링이나 오일리스 메탈 사용
- 영구자석(Permanent Magnet) : 전기자 권선에 자력을 제공하여 회전력을 발생
- 기타 부품 : 케이스, 앞·뒤 커버 등 모터의 구조를 보호 및 지지

### 제어 방법
#### 트랜지스터 구동 (에미터 부하)
- 트랜지스터를 On/Off 하여 모터를 구동하는 방식입니다. 자동 부귀환으로 안정적인 동작이 가능하지만, 트랜지스터가 완전히 포화되지 못해 전압 손실이 크다는 단점이 있습니다.

#### 트랜지스터 구동 (컬렉터 부하)
- 트랜지스터 컬렉터에 모터를 연결하는 방식으로, 포화 영역에서 동작 가능하여 전압 손실이 작고 드라이브 능력이 큽니다. 일반적으로 가장 널리 사용됩니다.

#### 역기전력 처리
- 트랜지스터가 Off 되었을 때, 모터 코일에 저장된 에너지가 역기전력으로 발생하여 트랜지스터를 손상시킬 수 있습니다. 이를 방지하기 위해 다이오드(플라이휠 다이오드)를 병렬 연결하여 잔류 에너지를 소모합니다.

#### H-브리지 제어
- 모터의 정·역회전 제어를 위해 4개의 트랜지스터(Q1~Q4)를 H 형태로 배치한 회로입니다.
    - Q1, Q4 On → 정회전
    - Q2, Q3 On → 역회전
    - Q3, Q4 On → 브레이크

#### 속도 제어 방법
- 아날로그 방식
    - 트랜지스터를 전압 Dropper로 사용하여 모터에 가해지는 전압을 조절합니다. 회로가 단순하나, 전력 손실이 크고 발열이 심합니다.
- PWM 제어 (Pulse Width Modulation)
    - 펄스폭 변조 방식을 이용하여 On/Off 듀티비를 조절함으로써 평균 전압을 제어합니다. 전력 효율이 높고 발열이 적어 소형 및 중형 모터 제어에 널리 활용됩니다.

![DC Motor Schematic](res/DCMotor%20Schematic.png)

## DC 모터 연결 
| Pin | 연결 대상 | 설명 |
|:---:|:---:|:---|
| 12V | +12V | 전원 |
| GND | GND | 접지 |
| 8 | EN | DC Motor Enable |
| 9 | A | DC Motor A |
| 10 | B | DC Motor B |
| 2 | C1 | Encoder A |
| 3 | C2 | Encoder B |

## DC 모터 제어 

```cpp
int EN = 8;
int A = 9;   
int B = 10;

void setup() {
  pinMode(A, OUTPUT);
  pinMode(B, OUTPUT);
  pinMode(EN, OUTPUT);
  digitalWrite(EN, HIGH);
}

void loop() {
  analogWrite(B, 0);
  for (int speed = 0; speed <= 255; speed += 5) {
    analogWrite(A, speed); 
    delay(50);
  }
  delay(1000);

  analogWrite(A, 0);
  analogWrite(B, 180);
  delay(2000);

  analogWrite(A, 0);
  analogWrite(B, 0); 
  delay(1000);
}
```

## Encoder 
Encoder(엔코더)는 모터의 회전량, 속도, 방향을 검출하기 위한 센서로, DC 모터의 축에 부착되어 모터의 동작을 정밀하게 제어할 수 있도록 도와줍니다.
특히 로봇이나 자동화 시스템에서는 위치 피드백(Position Feedback)을 제공하여 PID 제어, 거리 계산, 속도 제어 등에 활용됩니다.

### Encoder 의 종류 
엔코더는 동작 원리에 따라 다음과 같이 구분됩니다.
| 구분 | 방식 | 특징 | 용도 |
| :--- | :--- | :--- | :--- |
| Incremental Encoder | 증분형 | 일정 간격마다 펄스를 출력하며, 펄스 수로 회전 각도나 속도를 계산 | 일반적인 DC 모터용 |
| Absolute Encoder | 절대형 | 회전 위치마다 고유한 코드값을 출력하여 절대 위치 확인 가능 | 산업용 로봇, 고정밀 장비 |
| Magnetic Encoder | 자기식 | 자석과 홀 센서(Hall Sensor)를 이용해 회전 검출 | 환경 변화에 강하고 내구성 높음 |
| Optical Encoder | 광학식 | LED와 포토센서로 디스크의 투명/불투명 패턴을 감지 | 정확도가 높지만 먼지에 취약 |

## Econder 측정 
다음 예제는 DC 모터의 회전에 따른 Encoder 측정값을 시리얼 모니터에 출력하는 코드입니다.
A, B 채널을 인터럽트 방식으로 감지하여 정확한 펄스 카운트를 출력합니다.

```cpp
int EN = 8;
int A = 9;   
int B = 10;
int ENCA = 2;
int ENCB = 3;

volatile long encoderCount = 0;
unsigned long lastEncoderTime = 0;
unsigned long lastChangeTime = 0;
long lastCount = 0;
bool dirFlag = false;
short int speed = 0;

void encoderISRA() {
  if(digitalRead(ENCA)!=digitalRead(ENCB)) {
    encoderCount++;
  }
  else {
    encoderCount--;
  }
}

void setup() {
  pinMode(ENCA, INPUT_PULLUP); 
  pinMode(ENCB, INPUT_PULLUP); 
  attachInterrupt(digitalPinToInterrupt(ENCA), encoderISRA, CHANGE);
  Serial.begin(115200);
  lastEncoderTime = millis();

  pinMode(A, OUTPUT);
  pinMode(B, OUTPUT);
  pinMode(EN, OUTPUT);

  digitalWrite(EN, HIGH);
}

void loop() {
  unsigned long now = millis();
  if(now - lastEncoderTime >= 100) {
    long count = encoderCount;
    long diff = count - lastCount;
    Serial.print("Count:");
    Serial.print(count);
    Serial.print("  dCount:");
    Serial.println(diff);
    lastCount = count;
    lastEncoderTime = now;
  }

  if(now - lastChangeTime >= 1000) {
    if(dirFlag) {
      analogWrite(A, 0);
      analogWrite(B, speed);
    }
    else {
      analogWrite(A, speed);
      analogWrite(B, 0);
    }
    speed+=10;
    Serial.print("Current speed : ");
    Serial.println(speed);
    if (speed >255) {
      speed = 0;
      dirFlag = !dirFlag;
    }
    lastChangeTime = now;
  }
}
```