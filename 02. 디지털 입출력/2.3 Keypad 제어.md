# Keypad 
## Keypad
Keypad는 여러 개의 스위치를 행(Row) 과 열(Column) 형태로 배치한 행렬(Matrix) 입력 방식의 입력 장치입니다.

PushSwitch처럼 각 키를 개별적으로 연결하는 직접 입력(Direct Input) 방식에 비해, 적은 수의 포트만으로 많은 키 입력을 처리할 수 있다는 장점이 있습니다. 예를 들어 4×4 Keypad는 16개의 키를 단 8개의 포트(4행 + 4열)로 제어할 수 있습니다.

이는 마치 행과 열이 교차하는 지점을 스캔(Scan) 하는 방식으로 동작하며, MCU는 각 행을 순서대로 LOW(0)로 만들고, 열 핀에서 입력 변화를 감지하여 어떤 키가 눌렸는지를 판별합니다.

![Keypad]()

하드웨어 회로는 다음과 같습니다. 

<img src="res/Keypad Schematic.png" style="width:80%;">

### Keypad 동작 원리 
1. 각 Row(행) 선을 순차적으로 LOW로 출력합니다.
2. 나머지 Column(열) 선들은 입력 모드로 설정합니다.
3. 어떤 열 핀에서 LOW가 감지되면, 현재 활성화된 행과 감지된 열의 교차점에 위치한 키가 눌린 것으로 판단합니다.

이 과정을 빠르게 반복 하면 사용자는 모든 키 입력이 실시간으로 인식되는 것처럼 느낄 수 있습니다. 

## Keypad 연결 
Keypad 하드웨어 연결은 다음과 같습니다. 

| Pin | 연결 대상 | 설명 |
|:---:|:---:|:---|
| 5V | +5V | 전원 |
| GND | GND | 접지 |
| 7 | R0 | Keypad ROW 0 |
| 6 | R1 | Keypad ROW 1 |
| 5 | R2 | Keypad ROW 2 |
| 4 | R3 | Keypad ROW 3 |
| 11 | C0 | Keypad COL 0 |
| 10 | C1 | Keypad COL 1 |
| 9 | C2 | Keypad COL 2 |
| 8 | C3 | Keypad COL 3 |

## Keypad 제어 프로그램 
Keypad의 스캔 기능을 직접 구현할 수도 있지만, Arduino에서는 Keypad 라이브러리를 통해 간단하게 행렬 키패드를 제어할 수 있습니다. 이 라이브러리는 내부적으로 행 스캔 → 열 판별 → 디바운싱 처리를 자동으로 수행해 줍니다.

```cpp
#include <Keypad.h>
 
char keys[4][4] = {
  {'0','1','2','3'},
  {'4','5','6','7'},
  {'8','9','A','B'},
  {'C','D','E','F'}
};

byte row_pin[4] = {7,6,5,4};
byte col_pin[4] = {11,10,9,8};

Keypad keypad = Keypad(makeKeymap(keys), col_pin, row_pin, 4, 4);
 
void setup(){
  Serial.begin(115200);
}
   
void loop(){
  char key = keypad.getKey();
  
  if(key){
    Serial.println(key);
  }
}
```

## Keypad를 활용한 반응속도 측정 게임 
다음 예제는 4×4 Keypad를 이용해 사용자의 반응속도(Reaction Time) 를 측정하는 게임입니다.
게임의 흐름은 다음과 같습니다.

1. Keypad 의 ‘F’ 키를 눌러 게임을 시작합니다.
2. 3초 카운트다운 후, 랜덤 목표키(Target Key) 가 표시됩니다.
3. 사용자가 올바른 키를 누르면 반응 시간이 기록됩니다.
4. 총 5회 반복 후 평균, 최대, 최소, 표준편차를 계산하여 결과를 출력합니다.

```cpp
#include <Keypad.h>

const byte ROWS = 4;
const byte COLS = 4;

char keys[ROWS][COLS] = {
  {'0','1','2','3'},
  {'4','5','6','7'},
  {'8','9','A','B'},
  {'C','D','E','F'}
};

byte row_pin[ROWS] = {7, 6, 5, 4};
byte col_pin[COLS] = {11, 10, 9, 8};
Keypad keypad = Keypad(makeKeymap(keys), col_pin, row_pin, ROWS, COLS);

const char START_KEY = 'F';
const uint8_t NUM_TRIALS = 5;
const uint8_t COUNTDOWN_START = 3;
const uint16_t TRIAL_TIMEOUT_MS = 2000;

const char ALL_KEYS[16] = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};
char targetPool[15];
uint8_t poolSize = 0;

enum GameState { GIDLE, COUNTDOWN, WAIT_TARGET, SHOW_RESULTS };
GameState state = GIDLE;

uint8_t  trialIndex = 0;
uint32_t reactionMs[NUM_TRIALS] = {0};

int countdownLeft = COUNTDOWN_START;
uint32_t tCountdownStart = 0;
uint8_t lastPrintedSecond = 255;
uint32_t tZeroMoment = 0;
char currentTarget = '?';

void buildTargetPool() {
  poolSize = 0;
  for (uint8_t i = 0; i < 16; i++)
    if (ALL_KEYS[i] != START_KEY) 
      targetPool[poolSize++] = ALL_KEYS[i];
}

char randomTargetKey() {
  return targetPool[random(poolSize)];
}

void printBanner() {
  Serial.println(F("====================================="));
  Serial.println(F("  4x4 Keypad Reaction Test Game"));
  Serial.print (F("  Start Key: '")); Serial.print(START_KEY); 
  Serial.println(F("' (16번)"));
  Serial.println(F("  Press F to start."));
  Serial.println(F("====================================="));
}

void startNewGame() {
  trialIndex = 0;
  for (uint8_t i = 0; i < NUM_TRIALS; i++) 
    reactionMs[i] = 0;

  Serial.println();
  Serial.println(F("[게임 시작] 총 5회 반응 측정"));

  currentTarget = randomTargetKey();
  Serial.print(F("Round 1/5  목표키: ")); 
  Serial.print(currentTarget); 
  Serial.println();

  countdownLeft = COUNTDOWN_START;
  lastPrintedSecond = 255;
  tCountdownStart = millis();
  state = COUNTDOWN;
}

void startNextTrial() {
  trialIndex++;
  if (trialIndex >= NUM_TRIALS) { 
    state = SHOW_RESULTS; 
    return; 
  }

  currentTarget = randomTargetKey();
  Serial.println();
  Serial.print(F("Round ")); 
  Serial.print(trialIndex + 1);
  Serial.print(F("/")); 
  Serial.print(NUM_TRIALS);
  Serial.print(F("  목표키: ")); 
  Serial.print(currentTarget); 
  Serial.println();

  countdownLeft = COUNTDOWN_START;
  lastPrintedSecond = 255;
  tCountdownStart = millis();
  state = COUNTDOWN;
}

void showResults() {
  Serial.println();
  Serial.println(F("===== 결과 ====="));
  uint32_t sum = 0;
  for (uint8_t i = 0; i < NUM_TRIALS; i++) {
    Serial.print(F("Trial ")); 
    Serial.print(i + 1);
    Serial.print(F(": ")); 
    Serial.print(reactionMs[i]); 
    Serial.println(F(" ms"));
    sum += reactionMs[i];
  }

  uint32_t mn = reactionMs[0], mx = reactionMs[0];
  for (uint8_t i = 1; i < NUM_TRIALS; i++) {
    if (reactionMs[i] < mn) 
      mn = reactionMs[i];
    if (reactionMs[i] > mx) 
      mx = reactionMs[i];
  }

  float avg = sum / (float)NUM_TRIALS;
  float var = 0;
  for (uint8_t i = 0; i < NUM_TRIALS; i++) { 
    float d = reactionMs[i] - avg; 
    var += d * d; 
  }
  var /= NUM_TRIALS;
  float stddev = sqrt(var);

  Serial.print(F("최소: ")); 
  Serial.print(mn); 
  Serial.println(F(" ms"));
  Serial.print(F("최대: ")); 
  Serial.print(mx); 
  Serial.println(F(" ms"));
  Serial.print(F("평균: ")); 
  Serial.print(avg, 2); 
  Serial.println(F(" ms"));
  Serial.print(F("표준편차: ")); 
  Serial.print(stddev, 2); 
  Serial.println(F(" ms"));
  Serial.println(F("================"));
  Serial.println(F("게임 종료. 'F'(16번)을 누르면 다시 시작합니다."));
  state = GIDLE;
}

void setup() {
  Serial.begin(115200);
  keypad.setDebounceTime(20);
  keypad.setHoldTime(250);
  randomSeed((uint32_t)micros());
  buildTargetPool();
  printBanner();
}

void loop() {
  char key = keypad.getKey();

  if (key == START_KEY) {
    if (state == GIDLE) 
      startNewGame();
  }

  switch (state) {
    case GIDLE: {
      // 대기 상태: 필요 시 디버깅만
      /* if (key && key != START_KEY) {
        Serial.print(F("(대기 입력: ")); Serial.print(key); Serial.println(')');
      } */
    } break;
    case COUNTDOWN: {
      if (key && key != START_KEY) {
        Serial.println(F("[경고] 아직 0이 아닙니다! 성급한 입력."));
      }

      uint32_t now = millis();
      int secElapsed = (now - tCountdownStart) / 1000;
      int left = COUNTDOWN_START - secElapsed;

      if (left >= 0 && lastPrintedSecond != left) {
        lastPrintedSecond = left;
        Serial.print(F("... ")); 
        Serial.println(left);
      }

      if (left <= 0) {
        Serial.println(F("0! GO! 목표키를 누르세요."));
        Serial.print (F("목표키: ")); 
        Serial.print(currentTarget); 
        Serial.println();
        tZeroMoment = millis();
        state = WAIT_TARGET;
      }
    } break;
    case WAIT_TARGET: {
      if (millis() - tZeroMoment > TRIAL_TIMEOUT_MS) {
        reactionMs[trialIndex] = TRIAL_TIMEOUT_MS;
        Serial.println(F("시간초과(미스)!"));
        startNextTrial();
        break;
      }

      if (key) {
        if (key == currentTarget) {
          uint32_t t = millis() - tZeroMoment;
          reactionMs[trialIndex] = t;
          Serial.print(F("정답, 반응시간: "));
          Serial.print(t); 
          Serial.println(F(" ms"));
          startNextTrial();
        } 
      }
    } break;
    case SHOW_RESULTS: {
      showResults();
    } break;
  }
}
```